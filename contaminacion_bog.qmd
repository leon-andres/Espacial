---
title: "Análisis espacial de la concentración de PM2.5 y PM10 en estaciones de monitoreo de calidad del aire en Bogotá"
date: 06-21-2025
author: 
  - "Jerson Vargas Galeano"
  - "Andres David Leon Hernandez"
format: html
editor: visual
---

## Planteamiento del problema

La contaminación del aire es uno de los principales problemas ambientales que afectan la salud pública, especialmente en las ciudades. En Bogotá, el seguimiento de contaminantes como el PM2.5 y el PM10 se hace por medio de estaciones distribuidas por toda la ciudad. Aun así, todavía hay muchas cosas que no se entienden del todo bien sobre cómo se comportan estos contaminantes en el espacio y el tiempo. Analizar esos patrones puede ser útil para plantear políticas ambientales más efectivas y mejor enfocadas.

## **Objetivos**

### **Objetivo general**

Analizar la distribución espacio-temporal de los contaminantes PM2.5 y PM10 en Bogotá utilizando los datos provenientes de las estaciones de monitoreo del IDEAM.

### **Objetivos específicos**

-   Observar cómo se distribuyen las concentraciones promedio de PM2.5 y PM10 en diferentes partes del país.

-   Identificar zonas con mayores concentraciones y posibles focos de contaminación.

-   Examinar cómo la ubicación geográfica podría influir en los niveles de PM2.5 y PM10.

## **Resultados esperados**

-   Mapas temáticos que ilustren la distribución espacial de PM2.5 y PM10 en Colombia.

-   Modelos de regresión que nos permitan determinar si existe una relación significativa entre las concentraciones de los contaminantes y su ubicación geográfica.

-   Posibles clusters o áreas críticas donde se exceden los límites permisibles.

## **Variables**

### **Variables de interés (dependientes)**

-   **PM2.5**: está compuesto por partículas con un diámetro aerodinámico igual o menor a 2.5 micrómetros. Su origen principal es la combustión de vehículos, industrias y quema de biomasa. Contiene sustancias como sulfatos, nitratos, metales pesados y carbono negro. Estas partículas pueden penetrar profundamente en los pulmones y pasar al torrente sanguíneo, provocando enfermedades respiratorias, cardiovasculares e incluso efectos neurológicos. Además, contribuyen a la formación de smog y disminución de visibilidad. Se mide en microgramos por metro cúbico $(\mu g/m^3)$ y la OMS establece límites estrictos por su alta peligrosidad.

-   **PM10**: incluye todas las partículas con un diámetro igual o menor a 10 micrómetros, por lo que abarca también el PM2.5. Su composición incluye polvo, polen, moho, cenizas y partículas de combustión. Proviene de fuentes naturales (como el polvo del suelo) y antrópicas (construcciones, vehículos). Aunque sus partículas son más grandes, pueden alojarse en las vías respiratorias superiores y causar irritación, tos o crisis asmáticas. También afectan la calidad del aire, deterioran estructuras y ecosistemas. Al igual que el PM2.5, se mide en $(\mu g/m^3)$ y es regulado por organismos de salud y medio ambiente.

### **Variables explicativas (independientes)**

-   **Coordenadas** (este y norte en metros) de las estaciones.

-   **Año** (dimensión temporal).

## **Análisis inicial de PM2.5**

# ANÁLISIS ESPACIAL DEL PM2.5

Este análisis se centra en el año 2022, periodo durante el cual se calcularon los promedios anuales de PM2.5 para cada estación de monitoreo en la ciudad de Bogotá. En total, se dispone de 20 estaciones, cada una proporcionando un valor representativo del promedio anual del contaminante, con base en observaciones diarias acumuladas durante el año.

Sin embargo, se identificó que la estación Carvajal–Sevillana presentó una representatividad temporal extremadamente baja, cercana al 16%, debido a que solo se registraron alrededor de 60 observaciones válidas en todo el año. En contraste, otras estaciones superaron las 220 observaciones, manteniendo representatividades superiores al 75%.

De acuerdo con el Informe Anual de Calidad del Aire de Bogotá 2022, esta deficiencia se debió a una serie de inconvenientes técnicos y logísticos. Durante los primeros meses del año (enero a mayo), no fue posible acceder a la estación por falta de permisos, lo que impidió el reemplazo oportuno de la cinta filtro y provocó fallas en los equipos de medición de diversos contaminantes. Posteriormente, en julio se detectaron fallas en el sistema de aire acondicionado, y para septiembre este quedó fuera de servicio por completo, invalidando las mediciones desde ese momento (Secretaría Distrital de Ambiente, 2023).

Dadas estas circunstancias, y con el fin de mantener la solidez del análisis geoestadístico, se decidió excluir la estación Carvajal–Sevillana del conjunto de datos, ya que su inclusión podría introducir sesgos significativos y afectar la validez del modelo espacial.

Este conjunto de datos permite una primera aproximación descriptiva y espacial del comportamiento del contaminante en la ciudad durante el año de estudio, sirviendo como base para los análisis geoestadísticos posteriores.

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: false


lista_librerías<-c("readr","sqldf","tidyr","tidyverse","ggplot2","patchwork","sp","fields","geoR","akima","shiny","gstat", "sf", "dplyr", "knitr", "raster", "scales", "reshape2", "broom", "readxl", "stringr", "purrr", "spacetime") 


no_installs <- lista_librerías[!lista_librerías %in% installed.packages()]

if(length(no_installs) > 0) {
  cat("Los siguientes paquetes no están instalados :\n")
  cat(no_installs, sep = "\n")
  install.packages(no_installs)
} else {
  cat("Todos los paquetes están instalados. \n")
}

sapply(lista_librerías, require, character = TRUE)
```

```{r}
#| include: false
datos <- read_csv("calidad_aire.csv", na = "N/A")

datos2 <- datos[,c(1,3:10,12,13,16,23:26,28)] 

# Promedio ponderado
dat2.5<-sqldf("select *
      from datos2
      where Variable = 'PM2.5' and Año = 2022 and `Código del Departamento`in (11) and
      `Representatividad Temporal` > 59
      and `Tiempo de exposición (horas)` = 24
      group by [ID Estacion], Variable, Año
      order by [ID Estacion], variable, Año")
```

```{r}
#| echo: false
#| warning: false
#| message: false
# Pasándo a coordenadas proyectadas
coords_geo <- SpatialPoints(cbind(dat2.5$Longitud, 
                                  dat2.5$Latitud),
                            proj4string = CRS("+proj=longlat +datum=WGS84"))
data_aire_geo <- data.frame(coords_geo,PM2_5 = dat2.5$Promedio)
CRS_UTM_CO <- CRS("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs")
coords_utm <- spTransform(coords_geo, CRS_UTM_CO)

#PM2.5 con promedio ponderado y cantidad de datos con las que se hace el promedio (pesos)
PM2_5 <- data.frame(coords_utm,PM2.5 = dat2.5$Promedio, TotDat = dat2.5$`No. de datos`)
PM2_5 <- PM2_5 %>%
  rename(
    este = coords.x1,
    norte = coords.x2
  )
```

### Visualización espacial de las estaciones de monitoreo

A continuación, se presenta un mapa que muestra la ubicación geográfica de las 19 estaciones de monitoreo de calidad del aire en Bogotá, utilizadas para el análisis del promedio anual de PM2.5 correspondiente al año 2022. Cada punto en el mapa representa una estación, y se ha utilizado tanto el color como el tamaño del punto para facilitar la interpretación visual de los datos.

La escala de colores indica el nivel de concentración de PM2.5 registrado por cada estación: los tonos azules corresponden a valores bajos, los morados a niveles intermedios, y los rojos a concentraciones más elevadas del contaminante. En cuanto al tamaño de los puntos, este representa la cantidad de observaciones válidas recolectadas en el año: puntos más pequeños reflejan estaciones con menor número de datos, mientras que los más grandes indican una mayor cobertura temporal.

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: false

colom_shp <- suppressMessages(st_read("mapa/loca.shp"))  # Ocultar mensajes de st_read
colom_shp <- st_transform(colom_shp[-9,], crs = "+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs")

PM2_5_sf <- st_as_sf(PM2_5, coords = c("este", "norte"), crs = CRS_UTM_CO)

```

```{r}
#| echo: false
#| message: false
#| warning: false

ggplot() +
  geom_sf(data = colom_shp, fill = "white", color = "black") +
  geom_sf(data = PM2_5_sf, aes(color = PM2.5, size = TotDat), alpha = 0.8) +
  scale_color_gradient(name = "PM2.5 (µg/m³)", low = "blue", high = "red") +
  labs(title = "Mapa de estaciones PM2.5 - Bogotá",
       subtitle = "Promedios con cantidad de datos como tamaño") +
  theme_minimal() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

```

En términos generales, la mayoría de estaciones presentan valores intermedios de PM2.5 (tonos morados), con una cobertura de entre 320 y 360 observaciones anuales, lo que garantiza una buena representatividad temporal. Sin embargo, existen algunas excepciones notables: la estación Colina, ubicada al norte de la ciudad, muestra una concentración particularmente baja de PM2.5 (zona azul), mientras que la estación Mochuelo, en el extremo sur, registra los niveles más altos (zona roja).

Además, se evidencia un gradiente espacial de contaminación que va desde el oriente hacia el occidente de la ciudad. Las estaciones ubicadas en el este, generalmente en zonas más elevadas, presentan concentraciones más bajas (tonos azulados o morados suaves), mientras que en el suroccidente, donde predominan zonas industriales y áreas con menor cobertura vegetal, se observan niveles más altos de PM2.5 (tonos rojizos o rosados).

Esta distribución sugiere que factores como la actividad industrial, la densidad vehicular y la topografía podrían estar influyendo en la dispersión del contaminante.

### Exploración de la relación entre PM2.5 y las coordenadas espaciales

Con el fin de explorar la posible influencia de la ubicación geográfica sobre los niveles de PM2.5, se realizaron gráficos de dispersión que muestran el comportamiento de esta variable en función de las coordenadas espaciales: Este (X) y Norte (Y). Ambos gráficos se presentan de manera conjunta, con la relación PM2.5 vs Este a la izquierda y PM2.5 vs Norte a la derecha, lo que permite una comparación visual directa.

```{r}
#| echo: false
#| warning: false
# Gráficos de la variable vs coordenadas
p1 <- ggplot(PM2_5, aes(x = este, y = PM2.5)) +
  geom_point(color = "blue") +
  labs(title = "PM2.5 vs Este", x = "Este (X)", y = "PM2.5") +
  theme_minimal()
p2 <- ggplot(PM2_5, aes(x = norte, y = PM2.5)) +
  geom_point(color = "blue") +
  labs(title = "PM2.5 vs Norte", x = "Norte (Y)", y = "PM2_5") +
  theme_minimal()
(p1 + p2)
```

En el gráfico correspondiente a la coordenada Este, se observa una posible tendencia decreciente de tipo lineal: a medida que aumenta la coordenada este, los valores de PM2.5 tienden a disminuir (tal y como se había percibido con anterioridad). Esto sugiere la existencia de un patrón espacial en dirección este-oeste. Por otro lado, el gráfico que relaciona PM2.5 con la coordenada Norte no muestra una tendencia clara ni un comportamiento sistemático, lo que indicaría una menor influencia de esta dimensión espacial sobre la variabilidad del contaminante.

Además, en ambos gráficos se identifica un posible valor atípico, representado por una observación con niveles notablemente altos de PM2.5. Este punto podría influir en el ajuste de modelos posteriores y debe ser tenido en cuenta en el análisis.

En conjunto, estos resultados preliminares sugieren que, como una primera aproximación, podría ser adecuado utilizar un modelo lineal con un término cuadrático que incluya únicamente la coordenada Este, con el fin de capturar la tendencia espacial observada en los datos.

#### Análisis de correlación entre PM2.5 y las coordenadas espaciales

Con el objetivo de respaldar cuantitativamente las observaciones realizadas en los gráficos anteriores, se procedió a calcular la matriz de correlación entre las variables PM2.5, Este y Norte. Aunque la relación entre las coordenadas Este y Norte no es de interés en este contexto, nos enfocamos particularmente en las correlaciones de PM2.5 con cada una de las coordenadas espaciales por separado.

```{r}
#| echo: false

c <- cor(PM2_5[, c("este", "norte", "PM2.5")])

# Convertir a formato largo para ggplot
c_melt <- melt(c)

# Gráfico
ggplot(c_melt, aes(Var1, Var2, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), color = "black", size = 4) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", 
                       midpoint = 0, limits = c(-1, 1), 
                       name = "Correlación") +
  theme_minimal() +
  labs(title = "Matriz de Correlación PM2.5", x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Los resultados muestran una correlación de aproximadamente -0.73 entre PM2.5 y la coordenada Este, lo que indica una fuerte relación inversa: a medida que se avanza hacia el este de la ciudad, los niveles de PM2.5 tienden a disminuir. En contraste, la correlación con la coordenada Norte es más débil, cercana a -0.46, lo que sugiere una tendencia decreciente menos marcada. Esta diferencia también se refleja en el mapa de calor de la matriz de correlaciones, donde la relación con la coordenada Este aparece en azul oscuro, indicando una asociación negativa fuerte, mientras que la relación con la coordenada Norte se muestra en un tono azul más claro.

### Ajuste del modelo de tendencia mediante regresión ponderada

Con base en la evidencia obtenida a partir de los gráficos de dispersión y el análisis de correlación, se procedió a ajustar un modelo de regresión lineal ponderado con el objetivo de extraer la tendencia espacial del contaminante PM2.5. En este caso, se utilizaron como ponderaciones el total de observaciones válidas registradas en cada estación de monitoreo, dado que los valores de PM2.5 corresponden a promedios ponderados. Por tanto, las estaciones con mayor cantidad de datos tienen un mayor peso en el análisis.

Durante el proceso de modelado, se exploraron diferentes especificaciones, incluyendo modelos con términos cuadráticos, interacciones y combinaciones de ambas coordenadas espaciales. No obstante, tras evaluar el desempeño de cada modelo, se determinó que el más adecuado para capturar la tendencia fue aquel que incluye únicamente la coordenada Este como variable explicativa, en sus términos lineal y cuadrático.

$$PM 2.5 = \beta_0 +\beta_1⋅Este + \beta_2⋅Este^2+ \epsilon$$

```{r}
#| echo: false
# MODELO PARA EXTRAER LA TENDENCIA, TENIENDO COMO PESO LOS TOTALES 

fit1 <- lm(PM2.5 ~ este + I(este^2), data = PM2_5, weights = TotDat)

# Extraer y mostrar coeficientes
tidy_fit <- tidy(fit1)
kable(tidy_fit, digits = 4, caption = "Resumen del modelo lineal ponderado")

```

Los resultados del modelo lineal ponderado final se presentan a continuación:

-   Intercepto: 13270.70

-   Coordenada Este: -0.0436

-   Cuadrado de la coordenada Este: 0.0000

Se decidió conservar el término cuadrático de la coordenada Este en el modelo, ya que su inclusión permitió reducir el coeficiente de variación de las predicciones en comparación con la alternativa que solo consideraba el término lineal. Esto sugiere que, aunque el efecto cuadrático no sea significativo de forma individual, sí contribuye a una mejor representación de la tendencia espacial en el conjunto de datos.

El modelo, ajustado utilizando ponderaciones según la cantidad de observaciones válidas por estación, será utilizado para remover la tendencia espacial del contaminante PM2.5. Este paso es necesario para enfocar los análisis posteriores en la estructura espacial de los residuos, sin que la tendencia interfiera en la estimación de la dependencia espacial propiamente dicha.

### Análisis gráfico de los residuos estandarizados

Una vez ajustado el modelo de tendencia, se procedió a evaluar el comportamiento de los residuos estandarizados con el fin de identificar posibles patrones espaciales residuales o la presencia de datos atípicos. Para ello, se realizaron gráficos de dispersión de los residuos estandarizados tanto frente a la coordenada Este como a la coordenada Norte, así como un diagrama de caja (boxplot).

```{r}
#| echo: false
res1 <- residuals(fit1)
par(mfrow = c(1, 3))

# Residuales estandarizados vs Coordenada Este
plot(PM2_5$este, rstandard(fit1),
     main = "Residuales vs Coordenada Este",
     xlab = "Este",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkblue")

# Residuales estandarizados vs Coordenada Norte
plot(PM2_5$norte, rstandard(fit1),
     main = "Residuales vs Coordenada Norte",
     xlab = "Norte",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkgreen")

# Boxplot de los residuales estandarizados
boxplot(rstandard(fit1),
        main = "Distribución de Residuales",
        ylab = "Residuales estandarizados",
        col = "red",
        ylim = c(-2, 3))

par(mfrow = c(1, 1))

PM2_5$residuals <- res1
```

En ambos gráficos de dispersión se observó un comportamiento razonablemente aleatorio, lo que sugiere que la tendencia ha sido correctamente eliminada. No obstante, en ambos casos se evidencian un posible dato atípico por su magnitud. Esta observación se refuerza con el boxplot, el cual identifica al menos un valor extremo, consistente con lo visto en los otros gráficos.

Aunque se utilizaron residuos estandarizados para facilitar la visualización y comparación, el análisis posterior se realizará con los residuos originales, ya que estos conservan la estructura espacial y magnitud real del error en la variable de interés.

A pesar de la presencia de este punto atípico, no se optó por eliminarlos, ya que forman parte del fenómeno real observado.

#### Visualización espacial y distribución de los residuos

Para complementar el análisis de los residuos, se realizó una exploración gráfica empleando funciones del paquete geoestadístico que permiten visualizar la distribución de los residuos en el espacio, así como su comportamiento multivariado.

```{r}
#| echo: false
# Objeto geodata
pmgs <- as.geodata(PM2_5, coords.col = 1:2, data.col = 6, covar.col = 5)
#summary(pmgs)

# Gráficos de la geodata
plot(pmgs, qt.col = c("purple",
                      "pink",
                      "green",
                      "yellow"))
```

Se generaron dos tipos principales de gráficos de interés:

-   **Gráfico de cuantiles espaciales**: Este gráfico muestra la ubicación de los residuos en el plano espacial (coordenadas Este y Norte), codificados por colores según sus cuantiles. La mezcla de colores indica que los residuos están distribuidos espacialmente sin un patrón sistemático ni agrupamientos claros, lo que confirma que la tendencia principal fue efectivamente eliminada en el ajuste del modelo.

-   **Gráficos de densidad**: Este gráfico permite visualizar que la mayor concentración de residuos está cerca de valores bajos, reforzando la idea de que los residuos están centrados alrededor de cero y que no existe una fuerte dependencia espacial no explicada.

En conjunto, estas visualizaciones apoyan la validez del modelo ajustado y justifican avanzar al análisis geoestadístico mediante la estimación del semivariograma, considerando que los residuos representan el componente espacial de interés.

### Estimación del semivariograma y uso de un estimador robusto

En esta sección se procede a estimar el semivariograma empírico de los residuos obtenidos del modelo de regresión ponderada previamente ajustado. Esta estimación tiene como objetivo analizar la dependencia espacial de los residuos, lo cual es esencial antes de aplicar cualquier modelo geoestadístico. Se plantea el uso de el estimador clásico del semivariograma.

#### Semivariograma clásico

Se calculó el semivariograma empírico utilizando el estimador clásico definido como:

$$
\hat{\gamma}(h) = \frac{1}{2N(h)} \sum_{i=1}^{N(h)} \left[ Z(s_i + h) - Z(s_i) \right]^2
$$ donde N(h) representa el número de pares de puntos separados por una distancia aproximadamente igual a h, y Z(s) representa el valor del proceso en la ubicación s.

Para garantizar la fiabilidad estadística de las estimaciones, se consideraron únicamente aquellos rezagos h donde se cumpliera que N(h)\>5. Esto se hace para asegurar que el número de pares sea suficiente para obtener un promedio representativo en cada distancia, evitando valores extremadamente inestables o influenciados por unos pocos datos, lo cual es especialmente importante en rezagos donde los datos están dispersos o hay menor cobertura espacial.

```{r}
#| echo: false
#| results: false

# Variograma empírico para los residuales usando el estimador clásico
vari1 <- variog(pmgs, trend = "cte", estimator.type = "classical", bin.cloud = T, pairs.min = 5, max.dist = 20000)

```

```{r}
#| echo: false
# Graficar el variograma
plot(vari1)
title(main = "Variograma Empírico - Estimador Clásico\n(PM2.5 - Residuales)", cex.main = 1.2)
```

Al graficar el semivariograma empírico de los residuos del modelo ajustado para PM2.5, utilizando el estimador clásico de semivarianza, se observa un comportamiento creciente en los primeros rezagos de separación, seguido de una estabilización progresiva alrededor de los 7500 metros. Este patrón sugiere que existe correlación espacial positiva a distancias cortas, pero que dicha correlación se disipa a partir de esa distancia, es decir, las observaciones dejan de estar espacialmente relacionadas una vez superado ese umbral. Este comportamiento es coherente con la interpretación habitual del semivariograma, donde el punto de estabilización (alcance) indica la distancia a partir de la cual las mediciones son prácticamente independientes.

La forma creciente inicial, seguida por una meseta, sugiere que podrían ajustarse adecuadamente modelos teóricos como el exponencial, gaussiano, esférico o matern, los cuales reflejan estructuras de dependencia espacial que se debilitan progresivamente. Además, la ligera curvatura observada en los primeros lags podría justificar la consideración de un modelo tipo wave, aunque su elección dependerá de la calidad del ajuste y la naturaleza de los residuos.

### Ajuste de modelos teóricos al semivariograma empírico

Después de estimar el semivariograma empírico utilizando el estimador clásico de semivarianza, se procedió al ajuste de cinco modelos teóricos con el propósito de capturar adecuadamente la estructura de dependencia espacial presente en los residuos del modelo ajustado para PM2.5.

Como primer paso, se utilizó la herramienta interactiva eyefit, que permitió realizar un ajuste visual de distintos modelos teóricos al semivariograma empírico. A partir de esta exploración, se seleccionaron cinco estructuras comunes en geoestadística: esférico, exponencial, gaussiano, matern y wave, todas consideradas bajo el supuesto de pepita fija. Los valores iniciales de los parámetros para cada modelo se tomaron directamente del ajuste visual proporcionado por eyefit.

Con estos valores iniciales, se llevó a cabo el ajuste formal de cada modelo mediante un proceso de optimización, ponderando los errores según el número de pares de observaciones disponibles en cada rezago. Esto permitió obtener una versión ajustada de cada modelo teórico, los cuales serán comparados posteriormente para determinar cuál representa mejor la variabilidad espacial residual del contaminante.

```{r}
#| echo: false
#| results: false

#eyefit(vari1)

# Ajuste de semivariogramas con diferentes modelos y condiciones
ini1 <- c(5.21, 1981)
fitvar1 <- variofit(vari1,
                    cov.model = "wave",
                    ini = ini1,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini2 <- c(5.21, 5000)
fitvar2 <- variofit(vari1,
                    cov.model = "spherical",
                    ini = ini2,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini3 <- c(6, 5000)
fitvar3 <- variofit(vari1,
                    cov.model = "gaussian",
                    ini = ini3,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini4 <- c(6, 5000)
fitvar4 <- variofit(vari1,
                    cov.model = "exponential",
                    ini = ini4,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini5 <- c(7.03, 2477.17)
fitvar5 <- variofit(vari1,
                    cov.model = "matern",
                    ini = ini5,
                    fix.nugget = TRUE,
                    nugget=0,
                    fix.kappa = F,
                    kappa = 1.35,
                    wei = "npairs")

```

```{r}
#| echo: false

# Gráfico del semivariograma empírico y modelos ajustados
plot(vari1$u, vari1$v,
     xlab = "Distancia (h)",
     ylab = "Semivarianza",
     xlim = c(0,20000),
     ylim = c(0,8),
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Ajuste de Modelos Teóricos al Semivariograma Empírico",
     col.main = 4,
     cex.main = 1.3,
     pch = 20)

lines(fitvar1, col = "blue", lwd = 2, lty = 1)
lines(fitvar2, col = "red", lwd = 2, lty = 2)
lines(fitvar3, col = "darkgreen", lwd = 2, lty = 3)
lines(fitvar4, col = "darkorange", lwd = 2, lty = 3)
lines(fitvar5, col = "purple", lwd = 2, lty = 3)


legend("topleft",
       legend = c("Wave", "Espherical", "gaussian ", "exponential", "matern"),
       col = c("blue", "red", "darkgreen", "darkorange"),
       lty = 1:5,
       lwd = 2,
       bty = "n",
       text.col = "black")

```

Una vez realizados los ajustes, se graficaron los cinco modelos teóricos junto al semivariograma empírico. Visualmente, los cinco modelos parecen representar adecuadamente la estructura espacial de los datos. Todos capturan bien el incremento inicial de la semivarianza. Sin embargo, para decidir cuál de los modelos se ajusta mejor, se utilizará el criterio cuantitativo basado en el error cuadrático medio (RMSE), que permitirá comparar qué tan cerca está cada modelo de los valores empíricos en promedio.

Los resultados obtenidos para el RMSE de cada modelo fueron los siguientes:

```{r}
#| echo: false
# Función para predecir la semivarianza teórica en función de la distancia
predict_semivariogram <- function(model, h) {
  cov.model <- model$cov.model
  cov.pars <- model$cov.pars
  nugget <- model$nugget
  
  # γ(h) = sill - cov(h) + nugget
  sill <- cov.pars[1] + nugget
  gamma.h <- sill - geoR::cov.spatial(h, cov.model = cov.model, cov.pars = cov.pars)
  return(gamma.h)
}

# Función para calcular el RMSE
calc_rmse <- function(emp, model) {
  pred <- predict_semivariogram(model, emp$u)  # emp$u son distancias
  sqrt(mean((emp$v - pred)^2))                # emp$v son semivarianzas empíricas
}

# Calcular RMSE para cada ajuste
rmse1 <- calc_rmse(vari1, fitvar1)
rmse2 <- calc_rmse(vari1, fitvar2)
rmse3 <- calc_rmse(vari1, fitvar3)
rmse4 <- calc_rmse(vari1, fitvar4)
rmse5 <- calc_rmse(vari1, fitvar5)

# Mostrar resultados
rmse_comparacion <- c("Wave" = rmse1, "Espherical" = rmse2, "Gaussian" = rmse3,  Exponential= rmse4, Matern =rmse5)
knitr::kable(rmse_comparacion, col.names = c("Modelo", "RMSE"))
```

A partir de estos valores, se observa que el modelo exponencial presenta el menor RMSE, lo que indica que es el que mejor se ajusta al semivariograma empírico bajo este criterio.

```{r}
#| echo: false

library(knitr)

params <- data.frame(
  Parámetro = c("Modelo", 
                "Pepita (τ²)", 
                "Silla parcial (σ²)", 
                "Silla total (τ² + σ²)", 
                "Rango (ϕ)", 
                "Rango práctico (cor ≈ 0.05)"),
  Valor = c("Exponencial",
            0,
            round(fitvar4$cov.pars[1], 4),
            round(sum(fitvar4$cov.pars[1], 0), 4),
            round(fitvar4$cov.pars[2], 2),
            round(3 * fitvar4$cov.pars[2], 2))
)

kable(params, caption = "Resumen interpretado del ajuste de semivariograma")


```

El modelo de semivariograma que presentó el mejor ajuste fue el exponencial con pepita fija, con una silla total de 5.84 y un rango estimado de aproximadamente 4586.55 metros. Este rango representa la distancia a partir de la cual las observaciones espaciales comienzan a perder correlación de manera significativa. En el contexto urbano de Bogotá, este resultado sugiere que la influencia de las fuentes locales de emisión de PM2.5 —como zonas industriales, corredores viales o actividades residenciales— se extiende de forma efectiva en un radio de cerca de 4.5 kilómetros. Más allá de esta distancia, el comportamiento del contaminante tiende a volverse independiente entre estaciones.

```{r}
#| echo: false
# 1. Graficar el semivariograma empírico
plot(vari1,
     main = "Semivariograma empírico con modelo exponencial ajustado",
     xlab = "Distancia (h)",
     ylab = expression(gamma(h)))

# 2. Superponer el modelo teórico ajustado (fitvar1)
lines.variomodel(fitvar4, col = "blue", lwd = 2)


# 3. Guardar el modelo final para interpolación posterior
final_model <- fitvar4
```

## KRIGING DEL PM2.5

Una vez ajustado el modelo de semivariograma, se procedió a aplicar el método de kriging ordinario, con el objetivo de interpolar los valores residuales de PM2.5 en zonas no monitoreadas y así obtener una representación continua de la variabilidad espacial del contaminante en Bogotá. Para ello, se construyó una malla regular sobre el mapa de la ciudad, compuesta por celdas de 100 metros por 100 metros, tanto en dirección este-oeste como norte-sur. Esta malla sirve como base para estimar valores en ubicaciones intermedias entre las estaciones de monitoreo, permitiendo generar superficies suaves que reflejan los patrones espaciales inferidos a partir de los datos disponibles.

```{r}
#| include: false

# Obtenemos los polígonos
PM2_5_sf <- st_as_sf(PM2_5, coords = c("este", "norte"), crs = CRS_UTM_CO)

# Convertir a objeto Spatial
PM2_5_sp <- as(PM2_5_sf, "Spatial")

# Ajustar modelo de semivariograma
final_model <- vgm(psill = sum(fitvar4$cov.pars[1], 0),
                   model = "Exp",
                   range = fitvar4$cov.pars[2],
                   nugget = 0)

# Crear grilla usando límites del shapefile
bbox_colom <- st_bbox(colom_shp) # Se obtienen los extremos del shapefile
grilla <- expand.grid(
  x = seq(bbox_colom["xmin"], bbox_colom["xmax"], by = 100),
  y = seq(bbox_colom["ymin"], bbox_colom["ymax"], by = 100)
) # Se crea la grilla
coordinates(grilla) <- ~x + y # Se convierte la grilla en un objeto espacial
gridded(grilla) <- TRUE # Convierte la grilla en una estructura de celda, no de puntos
proj4string(grilla) <- CRS(st_crs(colom_shp)$proj4string) #Le asigna el sistema de referencia espacial del shapefile original

# Kriging
kriging_result <- krige(residuals ~ 1, PM2_5_sp, grilla, model = final_model) #Predicción

# 
# # Resumen
# summary(kriging_result@data$var1.pred)
# summary(kriging_result@data$var1.var)
```

```{r}
#| echo: false

# 1. Convertir resultado de kriging a raster
kriging_raster <- raster(kriging_result["var1.pred"]) #Lo transforma en una imagen de mapa

# 2. Convertir el shapefile de Colombia a Spatial
colom_sp <- as(colom_shp, "Spatial")

# 3. Recortar el raster con el polígono de Colombia
kriging_raster_masked <- mask(kriging_raster, colom_sp) #Recorta el mapa visual usando el shapefile

# 4. Convertir a dataframe para ggplot
kriging_df <- as.data.frame(kriging_raster_masked, xy = TRUE)
kriging_df <- na.omit(kriging_df) #Quitamos los na que quedaran por fuera del shapefile

# 5. Agregar variable de tendencia: PM2.5 ~ este
kriging_df$este <- kriging_df$x
kriging_df$este2 <- kriging_df$este^2  
kriging_df$tendencia <- predict(fit1, newdata = kriging_df)

# 6. Sumar kriging de residuos + tendencia
kriging_df$PM25_estimado <- kriging_df$var1.pred + kriging_df$tendencia

# 7. Graficar mapa final
library(ggplot2)

gr1 <- ggplot() +
  geom_raster(data = kriging_df, aes(x = x, y = y, fill = PM25_estimado)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "PM2.5 estimado (µg/m³)",
    colours = c("navy", "deepskyblue", "limegreen", "yellow", "orange", "firebrick"),
    na.value = NA
  ) +
  labs(
    title = "Mapa estimado de PM2.5",
    subtitle = "Tendencia lineal + Kriging de residuos",
    caption = "Interpolación con modelo exponencial"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()
print(gr1)

```

El mapa estimado de concentraciones anuales de PM2.5 en Bogotá, obtenido a partir del proceso de kriging, revela un patrón espacial claramente diferenciado a lo largo del territorio urbano. Los colores van desde el azul (valores más bajos) hasta el rojo (valores más altos), permitiendo una lectura visual intuitiva de la distribución del contaminante. Se observa que las zonas norte, nororiente y oriente de la ciudad presentan niveles considerablemente bajos, con valores promedio cercanos o incluso inferiores a los 15 microgramos por metro cúbico, destacándose un punto en el norte con valores aún más bajos. En contraste, conforme se avanza hacia el occidente y especialmente hacia el suroccidente, los niveles de PM2.5 aumentan progresivamente, alcanzando valores promedio cercanos a 30 microgramos por metro cúbico en los extremos occidentales de la ciudad.

Este comportamiento puede estar relacionado con diversos factores urbanos y ambientales. En el oriente y nororiente predominan zonas residenciales de baja densidad, con mayor presencia de cobertura vegetal y menor carga vehicular, además de estar ubicadas en sectores de mayor altitud y mejor ventilación. Por el contrario, el occidente y suroccidente concentran una mayor presencia de actividad industrial, corredores viales de alto tráfico, y asentamientos densos, lo que favorece la acumulación de material particulado fino. Adicionalmente, la topografía inclinada hacia el occidente podría dificultar la dispersión de contaminantes en esas zonas.

Desde una perspectiva de salud pública y gestión ambiental, estas estimaciones resaltan la necesidad de intervenciones focalizadas en el occidente de la ciudad, particularmente en localidades como Kennedy, Bosa, Fontibón y Puente Aranda, donde residen comunidades potencialmente más expuestas a concentraciones perjudiciales de PM2.5. Se recomienda priorizar estas zonas en estrategias de mitigación, como el control de fuentes móviles y fijas de emisión, la expansión de zonas verdes, y el monitoreo reforzado. Este tipo de análisis espacial puede apoyar la toma de decisiones basadas en evidencia para una planificación ambiental más equitativa y eficiente.

```{r}
#| echo: false
# 1. Convertir la varianza de predicción a raster
kriging_var_raster <- raster(kriging_result["var1.var"])

# 2. Recortar con el polígono de Colombia
kriging_var_masked <- mask(kriging_var_raster, colom_sp)

# 3. Convertir a dataframe para ggplot
kriging_var_df <- as.data.frame(kriging_var_masked, xy = TRUE)
kriging_var_df <- na.omit(kriging_var_df)

# 4. Mapa de la varianza (variabilidad del kriging)
gr2 <- ggplot() +
  geom_raster(data = kriging_var_df, aes(x = x, y = y, fill = var1.var)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Varianza de predicción",
    colours = c("white", "lightblue", "deepskyblue", "blue", "navy"),
    na.value = NA
  ) +
  labs(
    title = "Mapa de incertidumbre del kriging",
    subtitle = "Varianza de predicción espacial (PM2.5)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr2)

```

Además del mapa estimado de concentraciones de PM2.5, se construyeron dos mapas complementarios que permiten evaluar la incertidumbre asociada a las predicciones del kriging: el mapa de la varianza de predicción y el mapa del coeficiente de variación (CV).

El mapa de la varianza de predicción, con valores que oscilan entre 0 y 6, se representa mediante una escala de color que va desde el blanco (baja varianza) hasta el azul oscuro (alta varianza). Se observa claramente que las zonas con mayor densidad de estaciones de monitoreo —principalmente en el centro de la ciudad— presentan los niveles más bajos de incertidumbre, como es esperable, ya que las predicciones del kriging son más confiables en puntos cercanos a datos observados. En cambio, en zonas periféricas o más alejadas de las estaciones, especialmente en los extremos nororientales y surorientales, la varianza tiende a aumentar, reflejando mayor incertidumbre.

```{r}
#| echo: false
#| warning: false
library(raster)
library(ggplot2)

# 1. Raster de desviación estándar (raíz cuadrada de la varianza)
kriging_sd_raster <- sqrt(raster(kriging_result["var1.var"]))

# 2. Raster de valor estimado (ya sumaste tendencia + kriging residuos)
# Aquí asumimos que tienes el raster de valores estimados (o creas uno desde dataframe):
# Supongamos que kriging_df$PM25_estimado es tu estimado en dataframe
# Primero convertir dataframe a raster (si no lo tienes):

coordinates(kriging_df) <- ~x+y
gridded(kriging_df) <- TRUE
PM25_estimado_raster <- raster(kriging_df["PM25_estimado"])

# 3. Recortar raster con polígono Colombia
colom_sp <- as(colom_shp, "Spatial")
kriging_sd_masked <- mask(kriging_sd_raster, colom_sp)
PM25_estimado_masked <- mask(PM25_estimado_raster, colom_sp)

# 4. Calcular raster de CV (%) 
cv_raster <- (kriging_sd_masked / PM25_estimado_masked) * 100

# 5. Convertir a dataframe para ggplot
cv_df <- as.data.frame(cv_raster, xy = TRUE)
cv_df <- na.omit(cv_df)

# 6. Graficar coeficiente de variación (%)
gr3 <- ggplot() +
  geom_raster(data = cv_df, aes(x = x, y = y, fill = layer)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Coeficiente de Variación (%)",
    colours = c("white", "yellow", "orange", "red", "darkred"),
    na.value = NA
  ) +
  labs(
    title = "Mapa del Coeficiente de Variación (CV) del Kriging",
    subtitle = "Incertidumbre relativa de PM2.5"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr3)
# a1 <- data.frame(PM25_estimado = kriging_df$PM25_estimado,
#                 varianza = kriging_var_df$var1.var,
#                 cv = sqrt(kriging_var_df$var1.var) / abs(kriging_df$PM25_estimado)*100)

```

Por su parte, el mapa del coeficiente de variación presenta valores que van desde 0% hasta aproximadamente 17%, codificados en una escala de colores que va del amarillo claro al rojo oscuro. Este indicador estandariza la incertidumbre en relación con el valor predicho, y en general muestra niveles bajos o moderados, lo cual indica una buena estabilidad relativa en las estimaciones. Al igual que con la varianza, las zonas cercanas a estaciones de monitoreo presentan los valores más bajos de CV. Sin embargo, se evidencia un patrón creciente desde el occidente hacia el oriente, siendo la franja oriental de la ciudad —donde la cobertura de estaciones es menor— la región con mayor coeficiente de variación. Esto sugiere que, si bien las predicciones en estas zonas pueden seguir siendo útiles, deben interpretarse con mayor precaución debido a su mayor nivel de incertidumbre relativa.

### Medidas de calidad asociadas

Finalmente, se calcularon tres medidas de calidad para evaluar el desempeño del modelo de kriging en la predicción del contaminante PM2.5: el Error Medio (ME) fue de aproximadamente -0.0574, indicando que, en promedio, el modelo no presenta sesgo significativo en sus estimaciones. El Error Absoluto Medio (MAE) fue de 2.3437, lo que sugiere que, en promedio, la desviación entre los valores predichos y observados es relativamente baja considerando que los niveles anuales de PM2.5 en Bogotá oscilan entre 15 y 30 microgramos por metro cúbico. Por su parte, la Raíz del Error Cuadrático Medio (RMSE) alcanzó un valor de 3.2826, lo cual refuerza la idea de que el modelo logra una buena aproximación general del comportamiento espacial del contaminante. En conjunto, estos resultados respaldan la utilidad del kriging como herramienta de interpolación en este contexto, permitiendo obtener estimaciones razonables en zonas no monitoreadas de la ciudad.

```{r}
#| echo: false
#| warning: false
#| message: false


# 1. Ajustar modelo final del variograma
final_model <- vgm(
  psill = sum(fitvar4$cov.pars[1], 0),
  model = "Exp",
  range = fitvar4$cov.pars[2],
  nugget = 0
)

# 2. Validación cruzada Leave-One-Out
cv_result <- krige.cv(residuals ~ 1, 
                      PM2_5_sp, 
                      model = final_model,
                      nfold = nrow(PM2_5_sp))  # LOO-CV

# 3. Convertir a data.frame
cv_df <- as.data.frame(cv_result)

# 4. Calcular errores
cv_df$error <- cv_df$observed - cv_df$var1.pred

# 5. Métricas de desempeño
ME   <- mean(cv_df$error)
MAE  <- mean(abs(cv_df$error))
RMSE <- sqrt(mean(cv_df$error^2))

# 6. Tabla de errores principales
errores <- data.frame(
  Métrica = c("Error Medio (ME)", 
              "Error Absoluto Medio (MAE)", 
              "Raíz del Error Cuadrático Medio (RMSE)"),
  Valor = round(c(ME, MAE, RMSE), 4)
)

k1 <- kable(errores, caption = "Resumen de medidas de calidad asociadas para el kriging de PM2.5")
k1
```

## CONCLUSIÓN DEL ANÁLISIS ESPACIAL DE PM2.5

Más allá de los aspectos técnicos, los resultados del análisis espacial permiten visibilizar desigualdades ambientales relevantes dentro del territorio urbano de Bogotá. El hecho de que las zonas occidentales y suroccidentales concentren los niveles más altos de PM2.5 no es un hallazgo menor: estas áreas corresponden a localidades densamente pobladas como Bosa, Kennedy y Fontibón, donde habitan cientos de miles de personas en condiciones que, muchas veces, combinan vulnerabilidad social con exposición ambiental. El patrón observado no es aleatorio; está vinculado con la presencia de fuentes de emisión intensas, como vías de alto tráfico, zonas industriales y procesos urbanos poco planificados.

En contraste, los sectores del norte y nororiente, donde los niveles del contaminante son marcadamente más bajos, tienden a contar con mejores condiciones urbanas: mayor cobertura vegetal, menor densidad poblacional, mejores flujos de aire y menor concentración de fuentes contaminantes. Esto pone en evidencia que la exposición al riesgo ambiental no se distribuye equitativamente y que la calidad del aire, en muchos casos, se convierte en un indicador indirecto de desigualdad territorial.

Por tanto, más allá del valor numérico, este análisis subraya la urgencia de intervenciones diferenciadas, que prioricen las zonas más afectadas. La planificación urbana, el transporte público limpio, la regulación industrial y la expansión de zonas verdes deben ser diseñados con un enfoque territorial justo, que reconozca que el derecho a respirar aire limpio también es una cuestión de equidad social.

# ANÁLISIS ESPACIAL DEL PM10

A continuación, se replica el análisis espacial aplicado previamente al contaminante PM2.5, pero esta vez enfocado en el material particulado PM10. Al igual que antes, se parte de los promedios anuales por estación de monitoreo correspondientes al año 2022, con la misma red de 19 estaciones distribuidas en la ciudad de Bogotá. El objetivo es identificar patrones espaciales en la concentración de PM10 y evaluar su comportamiento mediante técnicas de interpolación geoestadística.

Dado que el procedimiento metodológico es el mismo —ajuste de tendencia, modelación de la dependencia espacial y aplicación de kriging ordinario—, en esta sección se resumirán los resultados principales, haciendo énfasis únicamente en aquellos aspectos que difieren de los hallazgos obtenidos con PM2.5, o que aportan información complementaria relevante para la comprensión de la calidad del aire en la ciudad.

```{r}
#| include: false

datos2 <- datos[,c(1,3:10,12,13,16,23:26,28)] 

# Promedio ponderado
dat10<-sqldf("select *
      from datos2
      where Variable = 'PM10' and Año = 2022 and `Código del Departamento`in (11) and
      `Representatividad Temporal` > 20
      and `Tiempo de exposición (horas)` = 24
      group by [ID Estacion], Variable, Año
      order by [ID Estacion], variable, Año")
```

```{r}
#| echo: false
#| warning: false
#| message: false
# Pasándo a coordenadas proyectadas
coords_geo <- SpatialPoints(cbind(dat10$Longitud, 
                                  dat10$Latitud),
                            proj4string = CRS("+proj=longlat +datum=WGS84"))
data_aire_geo <- data.frame(coords_geo,PM10 = dat10$Promedio)
CRS_UTM_CO <- CRS("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs")
coords_utm <- spTransform(coords_geo, CRS_UTM_CO)

#PM2.5 con promedio ponderado y cantidad de datos con las que se hace el promedio (pesos)
PM10 <- data.frame(coords_utm,PM10 = dat10$Promedio, TotDat = dat10$`No. de datos`)
PM10 <- PM10 %>%
  rename(
    este = coords.x1,
    norte = coords.x2
  )
```

### Visualización espacial de las estaciones de monitoreo

```{r}
#| echo: false
#| message: false
#| warning: false

# Para PM10
PM10_sf <- st_as_sf(PM10, coords = c("este", "norte"), crs = CRS_UTM_CO)

ggplot() +
  geom_sf(data = colom_shp, fill = "white", color = "black") +
  geom_sf(data = PM10_sf, aes(color = PM10, size = TotDat), alpha = 0.8) +
  scale_color_gradient(name = "PM10 (µg/m³)", low = "blue", high = "red") +
  labs(title = "Mapa de estaciones PM10 - Bogotá",
       subtitle = "Promedios con cantidad de datos como tamaño") +
  theme_minimal() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())


```

El mapa de estaciones de monitoreo para PM10 en el año 2022 muestra un patrón espacial similar al observado con PM2.5. Las zonas del norte y oriente de la ciudad presentan valores bajos del contaminante, representados con tonos azul oscuro, mientras que en el occidente, especialmente en el suroccidente, predominan tonos rosados y rojos, indicando mayores concentraciones. En cuanto al tamaño de los puntos, reflejo de la cantidad de datos registrados, la mayoría de estaciones cuenta con una buena densidad de observaciones, lo que aporta solidez al análisis posterior.

### Exploración de la relación entre PM2.5 y las coordenadas espaciales

```{r}
#| echo: false
#| warning: false
# Gráficos de la variable vs coordenadas
p3 <- ggplot(PM10, aes(x = este, y = PM10)) +
  geom_point(color = "blue") +
  labs(title = "PM10 vs Este", x = "Este (X)", y = "PM10") +
  theme_minimal()
p4 <- ggplot(PM10, aes(x = norte, y = PM10)) +
  geom_point(color = "blue") +
  labs(title = "PM10 vs Norte", x = "Norte (Y)", y = "PM10") +
  theme_minimal()
(p3 + p4)
```

Al analizar la relación entre PM10 y las coordenadas espaciales, se observa nuevamente un patrón decreciente claro en la dirección Este, lo cual sugiere una tendencia espacial similar a la del PM2.5. En contraste, respecto a la coordenada Norte, no se evidencia una relación aparente con los niveles del contaminante.

#### Análisis de correlación entre PM2.5 y las coordenadas espaciales

```{r}
#| echo: false
d <- cor(PM10[, c("este", "norte", "PM10")])

# Convertir a formato largo para ggplot
d_melt <- melt(d)

# Gráfico
ggplot(d_melt, aes(Var1, Var2, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2)), color = "black", size = 4) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", 
                       midpoint = 0, limits = c(-1, 1), 
                       name = "Correlación") +
  theme_minimal() +
  labs(title = "Matriz de Correlación PM10", x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

La matriz de correlaciones confirma lo observado en los gráficos previos: la variable PM10 presenta una fuerte correlación negativa con la coordenada Este (−0.85), lo que refuerza la presencia de una tendencia espacial decreciente en esa dirección. En cambio, su relación con la coordenada Norte es mucho más débil (−0.30), sin un patrón claro de variación.

### Ajuste del modelo de tendencia mediante regresión ponderada

```{r}
#| echo: false
# MODELO PARA EXTRAER LA TENDENCIA, TENIENDO COMO PESO LOS TOTALES 
fit2 <- lm(PM10 ~ este + I(este^2), data = PM10, weights = TotDat)

# Extraer y mostrar coeficientes
tidy_fit <- tidy(fit2)
kable(tidy_fit, digits = 4, caption = "Resumen del modelo lineal ponderado")
```

De manera similar al caso del PM2.5, se ajustó un modelo lineal ponderado utilizando la coordenada Este y su término cuadrático como variables explicativas, con el fin de extraer la tendencia espacial del PM10. Aunque los coeficientes no resultaron estadísticamente significativos, se optó por conservar el término cuadrático, ya que su inclusión permitió reducir el coeficiente de variación de las predicciones en etapas posteriores del análisis.

### Análisis gráfico de los residuos estandarizados

Al analizar los residuales estandarizados respecto a las coordenadas Este y Norte, se observa una distribución bastante homogénea, sin patrones espaciales evidentes, lo cual indica que la tendencia fue extraída de forma adecuada. El boxplot de los residuales muestra una dispersión centrada en cero. Y solo se observa un único valor atípico, que no afecta el análisis, ya que puede considerarse parte natural de la variabilidad de los datos ambientales.

```{r}
#| echo: false
res2 <- residuals(fit2)
par(mfrow = c(1, 3))

# Residuales estandarizados vs Coordenada Este
plot(PM10$este, rstandard(fit2),
     main = "Residuales vs Coordenada Este",
     xlab = "Este",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkblue")

# Residuales estandarizados vs Coordenada Norte
plot(PM10$norte, rstandard(fit2),
     main = "Residuales vs Coordenada Norte",
     xlab = "Norte",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkgreen")

# Boxplot de los residuales estandarizados
boxplot(rstandard(fit2),
        main = "Distribución de Residuales",
        ylab = "Residuales estandarizados",
        col = "red",
        ylim = c(-2, 3))

par(mfrow = c(1, 1))

PM10$residuals <- res2
```

```{r}
#| echo: false
# Objeto geodata
pmgs2 <- as.geodata(PM10, coords.col = 1:2, data.col = 6, covar.col = 5)
#summary(pmgs)

# # Gráficos de la geodata
# plot(pmgs2, qt.col = c("purple",
#                       "pink",
#                       "green",
#                       "yellow"))
```

## Estimación del semivariograma

#### Semivariograma clásico

```{r}
#| echo: false
#| results: false

# Variograma empírico para los residuales usando el estimador clásico
vari2 <- variog(pmgs2, trend = "cte", estimator.type = "classical", bin.cloud = T, pairs.min = 5, max.dist = 25000)

```

```{r}
#| echo: false

# Graficar el variograma
plot(vari2)
title(main = "Variograma Empírico - Estimador Clásico\n(PM10 - Residuales)", cex.main = 1.2)
```

El semivariograma empírico de los residuales del PM10 muestra valores iniciales elevados, y algunos de los primeros rezagos no se visualizan por no contar con suficientes pares de observaciones. A partir de una distancia cercana a los 7000 metros, el semivariograma comienza a estabilizarse, lo que sugiere que a partir de ese punto se pierde la correlación espacial entre los residuales, indicando un rango de dependencia espacial moderado.

### Ajuste de modelos teóricos al semivariograma empírico

```{r}
#| echo: false
#| results: false

#eyefit(vari2)

# Ajuste de semivariogramas con diferentes modelos y condiciones
ini1 <- c(18, 2700)
fitvar1 <- variofit(vari2,
                    cov.model = "wave",
                    ini = ini1,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini2 <- c(18, 7000)
fitvar2 <- variofit(vari2,
                    cov.model = "spherical",
                    ini = ini2,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini3 <- c(20,3250)
fitvar3 <- variofit(vari2,
                    cov.model = "gaussian",
                    ini = ini3,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini4 <- c(20,3250)
fitvar4 <- variofit(vari2,
                    cov.model = "exponential",
                    ini = ini4,
                    fix.nugget = TRUE,
                    nugget=0,
                    wei = "npairs")

ini5 <- c(18, 2000)
fitvar5 <- variofit(vari2,
                    cov.model = "matern",
                    ini = ini5,
                    fix.nugget = TRUE,
                    nugget=0,
                    fix.kappa = F,
                    kappa = 1.35,
                    wei = "npairs")


```

```{r}
#| echo: false

# Gráfico del semivariograma empírico y modelos ajustados
plot(vari2$u, vari2$v,
     xlab = "Distancia (h)",
     ylab = "Semivarianza",
     xlim = c(0,20000),
     ylim = c(0,28),
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Ajuste de Modelos Teóricos al Semivariograma Empírico",
     col.main = 4,
     cex.main = 1.3,
     pch = 20)

lines(fitvar1, col = "blue", lwd = 2, lty = 1)
lines(fitvar2, col = "red", lwd = 2, lty = 2)
lines(fitvar3, col = "darkgreen", lwd = 2, lty = 3)
lines(fitvar4, col = "darkorange", lwd = 2, lty = 3)
lines(fitvar5, col = "purple", lwd = 2, lty = 3)


legend("topleft",
       legend = c("Wave", "Espherical", "gaussian ", "exponential", "matern"),
       col = c("blue", "red", "darkgreen", "darkorange"),
       lty = 1:5,
       lwd = 2,
       bty = "n",
       text.col = "black")

```

```{r}
#| echo: false
# Función para predecir la semivarianza teórica en función de la distancia
predict_semivariogram <- function(model, h) {
  cov.model <- model$cov.model
  cov.pars <- model$cov.pars
  nugget <- model$nugget
  
  # γ(h) = sill - cov(h) + nugget
  sill <- cov.pars[1] + nugget
  gamma.h <- sill - geoR::cov.spatial(h, cov.model = cov.model, cov.pars = cov.pars)
  return(gamma.h)
}

# Función para calcular el RMSE
calc_rmse <- function(emp, model) {
  pred <- predict_semivariogram(model, emp$u)  # emp$u son distancias
  sqrt(mean((emp$v - pred)^2))                # emp$v son semivarianzas empíricas
}

# Calcular RMSE para cada ajuste
rmse1 <- calc_rmse(vari2, fitvar1)
rmse2 <- calc_rmse(vari2, fitvar2)
rmse3 <- calc_rmse(vari2, fitvar3)
rmse4 <- calc_rmse(vari2, fitvar4)
rmse5 <- calc_rmse(vari2, fitvar5)

# Mostrar resultados
rmse_comparacion <- c("Wave" = rmse1, "Espherical" = rmse2, "Gaussian" = rmse3,  Exponential= rmse4, Matern =rmse5)
knitr::kable(rmse_comparacion, col.names = c("Modelo", "RMSE"))
```

Se ajustaron nuevamente cinco modelos teóricos de semivariograma con pepita fija: Wave, Esférico, Gaussiano, Exponencial y Matérn. Todos mostraron un comportamiento razonable al ser comparados visualmente con el semivariograma empírico, siguiendo de forma adecuada la estructura de los datos. Finalmente, el modelo esférico fue seleccionado para el análisis, al ser uno de los que presentaba el menor error cuadrático medio (RMS) entre las opciones consideradas.

```{r}
#| echo: false

library(knitr)

params <- data.frame(
  Parámetro = c("Modelo", 
                "Pepita (τ²)", 
                "Silla parcial (σ²)", 
                "Sill total (τ² + σ²)", 
                "Rango (ϕ)", 
                "Rango práctico (cor ≈ 0.05)"),
  Valor = c("Esférico",
            0,
            round(fitvar2$cov.pars[1], 4),
            round(sum(fitvar2$cov.pars[1], 0), 4),
            round(fitvar2$cov.pars[2], 2),
            round(3 * fitvar2$cov.pars[2], 2))
)

kable(params, caption = "Resumen interpretado del ajuste de variograma (WLS)")


```

```{r}
#| echo: false
# 1. Graficar el semivariograma empírico
plot(vari2,
     main = "Semivariograma empírico con modelo ajustado esférico",
     xlab = "Distancia (h)",
     ylab = expression(gamma(h)))

# 2. Superponer el modelo teórico ajustado (fitvar1)
lines.variomodel(fitvar2, col = "blue", lwd = 2)


# 3. Guardar el modelo final para interpolación posterior
final_model <- fitvar2
```

## KRIGING DEL PM10

```{r}
#| include: false


PM10_sf <- st_as_sf(PM10, coords = c("este", "norte"), crs = CRS_UTM_CO)

# Convertir a objeto Spatial
PM10_sp <- as(PM10_sf, "Spatial")

# Ajustar modelo de semivariograma
final_model <- vgm(psill = sum(fitvar2$cov.pars[1], 0),
                   model = "Sph",
                   range = fitvar2$cov.pars[2],
                   nugget = 0)

# Crear grilla usando límites del shapefile
bbox_colom <- st_bbox(colom_shp)
grilla <- expand.grid(
  x = seq(bbox_colom["xmin"], bbox_colom["xmax"], by = 100),
  y = seq(bbox_colom["ymin"], bbox_colom["ymax"], by = 100)
)
coordinates(grilla) <- ~x + y
gridded(grilla) <- TRUE
proj4string(grilla) <- CRS(st_crs(colom_shp)$proj4string)

# Kriging indicador
kriging_result <- krige(residuals ~ 1, PM10_sp, grilla, model = final_model)

# 
# # Resumen
# summary(kriging_result@data$var1.pred)
# summary(kriging_result@data$var1.var)
```

```{r}
#| echo: false

# 1. Convertir resultado de kriging a raster
kriging_raster <- raster(kriging_result["var1.pred"])

# 2. Convertir el shapefile de Colombia a Spatial (si aún está en sf)
colom_sp <- as(colom_shp, "Spatial")

# 3. Recortar el raster con el polígono de Colombia
kriging_raster_masked <- mask(kriging_raster, colom_sp)

# 4. Convertir a dataframe para ggplot
kriging_df <- as.data.frame(kriging_raster_masked, xy = TRUE)
kriging_df <- na.omit(kriging_df)

# 5. Agregar variable de tendencia: PM2.5 ~ este
kriging_df$este <- kriging_df$x
kriging_df$este2 <- kriging_df$este^2  
kriging_df$tendencia <- predict(fit2, newdata = kriging_df)

# 6. Sumar kriging de residuos + tendencia
kriging_df$PM10_estimado <- kriging_df$var1.pred + kriging_df$tendencia

# 7. Graficar mapa final
library(ggplot2)

gr4 <- ggplot() +
  geom_raster(data = kriging_df, aes(x = x, y = y, fill = PM10_estimado)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "PM10 estimado (µg/m³)",
    colours = c("navy", "deepskyblue", "limegreen", "yellow", "orange", "firebrick"),
    na.value = NA
  ) +
  labs(
    title = "Mapa estimado de PM10",
    subtitle = "Tendencia lineal + Kriging de residuos",
    caption = "Interpolación con modelo gaussiano"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr4)

```

Tras ajustar el modelo esférico al semivariograma de los residuales y generar la malla espacial de interpolación (con celdas de 100 metros por 100 metros), se aplicó el método de kriging ordinario para estimar los niveles promedio anuales de PM10 en toda la ciudad. El mapa resultante muestra un patrón espacial muy similar al observado para el PM2.5: las zonas del norte, nororiente y oriente de Bogotá presentan niveles bajos de PM10, con valores alrededor de 30 microgramos por metro cúbico, representados en tonos azules y verdes. En contraste, hacia el occidente y suroccidente, los valores del contaminante aumentan considerablemente, alcanzando niveles entre 50 y más de 60, evidenciando una distribución geográfica desigual en la exposición a este contaminante.

```{r}
#| echo: false
# 1. Convertir la varianza de predicción a raster
kriging_var_raster <- raster(kriging_result["var1.var"])

# 2. Recortar con el polígono de Colombia
kriging_var_masked <- mask(kriging_var_raster, colom_sp)

# 3. Convertir a dataframe para ggplot
kriging_var_df <- as.data.frame(kriging_var_masked, xy = TRUE)
kriging_var_df <- na.omit(kriging_var_df)

# 4. Mapa de la varianza (variabilidad del kriging)
gr5 <- ggplot() +
  geom_raster(data = kriging_var_df, aes(x = x, y = y, fill = var1.var)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Varianza de predicción",
    colours = c("white", "lightblue", "deepskyblue", "blue", "navy"),
    na.value = NA
  ) +
  labs(
    title = "Mapa de incertidumbre del kriging",
    subtitle = "Varianza de predicción espacial (PM10)",
    caption = "Entre más oscuro, mayor incertidumbre"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr5)

```

```{r}
#| echo: false
#| warning: false

library(raster)
library(ggplot2)

# 1. Raster de desviación estándar (raíz cuadrada de la varianza)
kriging_sd_raster <- sqrt(raster(kriging_result["var1.var"]))

# 2. Raster de valor estimado (ya sumaste tendencia + kriging residuos)
# Aquí asumimos que tienes el raster de valores estimados (o creas uno desde dataframe):
# Supongamos que kriging_df$PM25_estimado es tu estimado en dataframe
# Primero convertir dataframe a raster (si no lo tienes):

coordinates(kriging_df) <- ~x+y
gridded(kriging_df) <- TRUE
PM10_estimado_raster <- raster(kriging_df["PM10_estimado"])

# 3. Recortar raster con polígono Colombia
colom_sp <- as(colom_shp, "Spatial")
kriging_sd_masked <- mask(kriging_sd_raster, colom_sp)
PM10_estimado_masked <- mask(PM10_estimado_raster, colom_sp)

# 4. Calcular raster de CV (%) 
cv_raster <- (kriging_sd_masked / PM10_estimado_masked) * 100

# 5. Convertir a dataframe para ggplot
cv_df <- as.data.frame(cv_raster, xy = TRUE)
cv_df <- na.omit(cv_df)

# 6. Graficar coeficiente de variación (%)
gr6<-ggplot() +
  geom_raster(data = cv_df, aes(x = x, y = y, fill = layer)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Coeficiente de Variación (%)",
    colours = c("white", "yellow", "orange", "red", "darkred"),
    na.value = NA
  ) +
  labs(
    title = "Mapa del Coeficiente de Variación (CV) del Kriging",
    subtitle = "Incertidumbre relativa de PM10") +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()


a2 <- data.frame(PM10_estimado = kriging_df$PM10_estimado,
                varianza = kriging_var_df$var1.var,
                cv = sqrt(kriging_var_df$var1.var) / abs(kriging_df$PM10_estimado)*100)

print(gr6)

```

En cuanto a la incertidumbre asociada a las predicciones, el mapa de varianza muestra valores bajos (de 0 a 20) en las zonas cercanas a las estaciones de monitoreo —destacadas con tonos blancos—, y valores crecientes hacia las regiones más alejadas, representadas en tonos azul oscuro, lo cual es esperable. Por su parte, el mapa del coeficiente de variación presenta un patrón similar al del PM2.5, pero con valores aún más altos, posiblemente debido a la mayor variabilidad del PM10. Se evidencia un aumento significativo del coeficiente de variación hacia el oriente, mientras que en el occidente los valores son considerablemente menores, reflejando mayor precisión en las estimaciones donde la densidad de monitoreo es más alta.

### Medidas de calidad asociadas

```{r}
#| echo: false
#| warning: false
#| message: false


# 2. Validación cruzada Leave-One-Out
cv_result <- krige.cv(residuals ~ 1, 
                      PM10_sp, 
                      model = final_model,
                      nfold = nrow(PM10_sp))  # LOO-CV

# 3. Convertir a data.frame
cv_df <- as.data.frame(cv_result)

# 4. Calcular errores
cv_df$error <- cv_df$observed - cv_df$var1.pred

# 5. Métricas de desempeño
ME   <- mean(cv_df$error)
MAE  <- mean(abs(cv_df$error))
RMSE <- sqrt(mean(cv_df$error^2))

# 6. Tabla de errores principales
errores <- data.frame(
  Métrica = c("Error Medio (ME)", 
              "Error Absoluto Medio (MAE)", 
              "Raíz del Error Cuadrático Medio (RMSE)"),
  Valor = round(c(ME, MAE, RMSE), 4)
)

k2<-kable(errores, caption = "Resumen de medidas de calidad asociadas para el kriging de PM10")

k2
```

Las medidas de calidad del kriging para PM10 muestran un error medio cercano a cero (−0.1841), lo que indica ausencia de sesgo sistemático en las predicciones. El MAE y el RMSE fueron de 4.46 y 5.39, respectivamente, reflejando una mayor variabilidad y dificultad de predicción frente al PM2.5, lo cual es coherente con el comportamiento más disperso del contaminante en la ciudad.

## CONCLUSIÓN DEL ANÁLISIS ESPACIAL DE PM10

El comportamiento espacial del PM10 en Bogotá durante 2022 resultó ser muy similar al del PM2.5, mostrando una distribución decreciente hacia el norte y oriente de la ciudad, y concentraciones más elevadas en el occidente y suroccidente. Esta tendencia fue confirmada tanto en el análisis exploratorio como en los modelos de tendencia y en la interpolación por kriging.

Sin embargo, a diferencia del PM2.5, el PM10 presentó una mayor variabilidad, reflejada en valores más altos del error de predicción y del coeficiente de variación. Esto sugiere que el PM10 es más disperso y menos predecible espacialmente, lo cual puede deberse a su origen mixto (natural y antropogénico) y a su mayor sensibilidad a condiciones locales como el viento, la resuspensión de polvo o la actividad vehicular pesada.

Pese a estas diferencias, los resultados permiten concluir que los patrones espaciales generales del PM10 son consistentes y confiables, y pueden ser útiles para apoyar la toma de decisiones ambientales y de salud pública en Bogotá.

# COKRIGING DE PM2.5

Con el objetivo de mejorar la precisión de las estimaciones espaciales del PM2.5, se implementó un análisis de Cokriging, utilizando como variable auxiliar el PM10, dada su alta correlación y su comportamiento espacial similar. Esta técnica permite aprovechar la información conjunta de ambas variables para refinar las predicciones del contaminante principal (PM2.5), especialmente en áreas con menor cobertura o mayor incertidumbre. El uso del Co-Kriging se justifica no solo por la relación estadística entre las variables, sino también por su coherencia desde el punto de vista físico y ambiental, al tratarse de dos partículas de material particulado con fuentes comunes y efectos similares.

## Cálculo de los semivariogramas empíricos

Para el desarrollo del modelo, se graficaron los semivariogramas empíricos marginales de PM2.5 y PM10, así como el semivariograma cruzado entre ambas variables. En los tres casos se observaron patrones similares, con algunos rezagos iniciales sin valores representados debido a la escasez de pares de observaciones en esas distancias cortas. A medida que la distancia entre puntos aumenta, los semivariogramas muestran un crecimiento progresivo, seguido por una estabilización alrededor de los 5.000 metros, lo que sugiere un rango común de dependencia espacial. Además, se identifican ciertas oscilaciones en la estructura de los datos, lo cual podría estar relacionado con fluctuaciones locales en la distribución de los contaminantes o con interacciones más complejas entre ambas variables.

```{r}
#| echo: false

df <- merge(PM2_5[,c(1,2,6)], PM10[,c(1,2,6)], by = c("este", "norte"), all = TRUE)
colnames(df)[3:4] <- c("PM2.5", "PM10")  # usa los nombres que usará gstat

# cor(df, use = "complete.obs")
# 
# summary(dist(df[,1:2]))


coordinates(df) <- ~este + norte

# summary(df)

df_ok <- df[!is.na(df$PM2.5) & !is.na(df$PM10), ]

# Define modelo gstat para cada variable
g <- gstat(NULL, id = "PM10", formula = PM10 ~ 1, data = df_ok)
g <- gstat(g,    id = "PM2.5", formula = PM2.5 ~ 1, data = df_ok)

# Calcula los variogramas directos y cruzado
# v <- variogram(g, cutoff = 14000, width = 1000)
v <- variogram(g, cutoff=14750, width = 1050)

v_filtrado <- v[v$np >= 5, ]

plot(v_filtrado, main = "Variogramas cruzados PM2.5 y PM10")
```

## Ajuste del modelo teórico

Para representar la dependencia espacial conjunta entre el PM2.5 y el PM10, se ajustó un Modelo Lineal de Coregionalización (LMC) a partir del semivariograma cruzado y los marginales. En esta etapa, se probaron distintas estructuras iniciales de tipo gaussiano, exponencial y esférico, todas con pepita igual a cero y rangos iniciales que variaban entre 6.000 y 10.000 metros. A cada una de estas configuraciones se le calculó su raíz del error cuadrático medio (RMSE) para evaluar el ajuste.

```{r}
#| echo: false
calcular_rmse_lmc <- function(ajuste_lmc, v_filtrado) {
  modelo_PM10 <- ajuste_lmc$model$PM10
  modelo_PM25 <- ajuste_lmc$model$PM2.5
  modelo_cross <- ajuste_lmc$model$PM10.PM2.5
  
  v_PM10 <- subset(v_filtrado, id == "PM10")
  v_PM25 <- subset(v_filtrado, id == "PM2.5")
  v_cross <- subset(v_filtrado, id == "PM10.PM2.5")
  
  pred_PM10 <- variogramLine(modelo_PM10, dist_vector = v_PM10$dist)
  pred_PM25 <- variogramLine(modelo_PM25, dist_vector = v_PM25$dist)
  pred_cross <- variogramLine(modelo_cross, dist_vector = v_cross$dist)
  
  rmse_PM10 <- sqrt(mean((v_PM10$gamma - pred_PM10$gamma)^2))
  rmse_PM25 <- sqrt(mean((v_PM25$gamma - pred_PM25$gamma)^2))
  rmse_cross <- sqrt(mean((v_cross$gamma - pred_cross$gamma)^2))
  
  mean(c(rmse_PM10, rmse_PM25, rmse_cross))
}

ajustar_y_evaluar_modelos <- function(v_filtrado, g, modelos_base) {
  resultados <- data.frame(Modelo = character(), RMSE = numeric(), stringsAsFactors = FALSE)
  
  for (nombre in names(modelos_base)) {
    modelo_inicial <- modelos_base[[nombre]]
    ajuste <- tryCatch({
      fit.lmc(v_filtrado, g, model = modelo_inicial)
    }, error = function(e) NULL)
    
    if (!is.null(ajuste)) {
      rmse <- calcular_rmse_lmc(ajuste, v_filtrado)
      resultados <- rbind(resultados, data.frame(Modelo = nombre, RMSE = rmse))
    }
  }
  
  resultados <- resultados[order(resultados$RMSE), ]
  return(resultados)
}

# Define tus modelos base, por ejemplo:
modelos_base <- list(
  Exp6000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 6000),
  Exp7000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 7000),
  Exp8000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 8000),
  Exp9000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 9000),
  Sph6000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 6000),
  Sph7000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 7000),
  Sph8000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 8000),
  Sph9000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 9000),
  Gau6000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 6000),
  Gau7000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 7000),
  Gau8000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 8000),
  Gau9000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 9000),
  Gau10000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 10000)
)
```

```{r}
#| echo: false
# Corre la comparación:
resultados <- ajustar_y_evaluar_modelos(v_filtrado, g, modelos_base)
print(resultados)
```

El modelo que presentó el menor RMSE fue el gaussiano con rango de 10.000 metros, motivo por el cual se seleccionó esta configuración como punto de partida para la optimización final. Posteriormente, se ajustaron los parámetros específicos de cada estructura (nugget y sill parcial) para las dos variables individuales y su interacción cruzada, obteniendo los siguientes valores:

```{r}
#| echo: false
#| message: false
#| warning: false

# 1. Definir estructura base (modelo gaussiano)
modelo_base <- vgm(psill = 20, model = "Gau", nugget = 0, range = 10000)

# 2. Ajustar modelo LMC con estructura compartida
lmc <- fit.lmc(v_filtrado, g, model = modelo_base)

# 3. Guardar sills totales antes de modificar (opcional)
sill_PM10_total      <- sum(lmc$model$PM10$psill)
sill_PM25_total      <- sum(lmc$model$PM2.5$psill)
sill_cross_total     <- sum(lmc$model$`PM10.PM2.5`$psill)

# 4. Definir nuggets deseados
nugget_PM10 <- 5
nugget_PM25 <- 0.5
nugget_cross <- 0

# 5. Reasignar psills: primero el nugget (posición 1), luego el sill estructural (posición 2)
lmc$model$PM10$psill[1]         <- nugget_PM10
lmc$model$PM2.5$psill[1]        <- nugget_PM25
lmc$model$`PM10.PM2.5`$psill[1] <- nugget_cross

lmc$model$PM10$psill[2]         <- sill_PM10_total - nugget_PM10
lmc$model$PM2.5$psill[2]        <- sill_PM25_total - nugget_PM25
lmc$model$`PM10.PM2.5`$psill[2] <- sill_cross_total - nugget_cross

# 6. Graficar el ajuste del modelo LMC
plot(v_filtrado, lmc, main = "Ajuste del Modelo Lineal de Coregionalización (LMC)")

# 7. Extraer parámetros en tabla
param_tab <- data.frame(
  Variable = c("PM10 (nugget)", "PM10 (estructura)",
               "PM2.5 (nugget)", "PM2.5 (estructura)",
               "PM10.PM2.5 (nugget)", "PM10.PM2.5 (estructura)"),
  Psill = c(
    lmc$model$PM10$psill[1], lmc$model$PM10$psill[2],
    lmc$model$PM2.5$psill[1], lmc$model$PM2.5$psill[2],
    lmc$model$`PM10.PM2.5`$psill[1], lmc$model$`PM10.PM2.5`$psill[2]
  ),
  Modelo = rep("Gaussiano", 6),
  Rango = rep(lmc$model$PM10$range[2], 6)
)

kable(param_tab, caption = "Parámetros ajustados del Modelo Lineal de Coregionalización (LMC)")


```

Estos resultados reflejan una estructura espacial común entre ambos contaminantes, con un rango de influencia compartido y una contribución cruzada significativa, lo cual valida la pertinencia del modelo para el posterior proceso de Cokriging.

## Predicciones para el PM2.5 usando cokriging

Tras ajustar el Modelo Lineal de Coregionalización, se procedió a realizar la interpolación del PM2.5 mediante Cokriging, utilizando el PM10 como variable auxiliar. El mapa resultante muestra una distribución espacial más marcada que la obtenida previamente con Kriging univariado. En particular, se observa que la zona norte, nororiente y suroriente de la ciudad presentan valores estimados de PM2.5 significativamente bajos, en el rango de 0 a 17 $\mu g/m^3$, lo cual sugiere mejores condiciones de calidad del aire en estas áreas. En contraste, la zona occidente de Bogotá concentra las mayores estimaciones del contaminante, alcanzando valores de hasta 30 $\mu g/m^3$ en el extremo occidental, y mostrando una clara transición desde niveles moderados (alrededor de 20) hacia niveles altos conforme se avanza hacia el occidente.

```{r}
#| echo: false
#| message: false
#| warning: false

# 0. Crear el objeto gstat con modelos ajustados desde LMC
g_cokrig <- gstat(NULL, id = "PM2.5", formula = PM2.5 ~ 1, data = df_ok, model = lmc$model$PM2.5)
g_cokrig <- gstat(g_cokrig, id = "PM10", formula = PM10 ~ 1, data = df_ok, model = lmc$model$PM10)
g_cokrig <- gstat(g_cokrig, id = c("PM2.5", "PM10"), model = lmc$model$PM10.PM2.5)


# 1. Crear grilla basada en el shapefile
bbox_colom <- st_bbox(colom_shp)
grilla <- expand.grid(
  x = seq(bbox_colom["xmin"], bbox_colom["xmax"], by = 100),
  y = seq(bbox_colom["ymin"], bbox_colom["ymax"], by = 100)
)

#496980.4

coordinates(grilla) <- ~x + y
gridded(grilla) <- TRUE
proj4string(grilla) <- CRS(st_crs(df_ok)$wkt)  # CRS consistente con los datos de entrenamiento

# 2. Predecir con cokriging (predicción y varianza)
pred <- predict(g_cokrig, newdata = grilla)





# 1. Convertir a dataframe
pred_df_total <- as.data.frame(pred, xy = TRUE)
pred_df_total <- na.omit(pred_df_total)

# 2. Crear variables necesarias para la tendencia (deben ser iguales a las del modelo fit1)
pred_df_total$este <- pred_df_total$x
pred_df_total$este2 <- pred_df_total$este^2  # si tu modelo tenía términos cuadráticos, ajusta según sea necesario

# 3. Predecir la tendencia con el modelo ajustado
pred_df_total$tendencia <- predict(fit1, newdata = pred_df_total)

# 4. Sumar tendencia + cokriging de residuos
pred_df_total$PM25_estimado <- pred_df_total$PM2.5.pred + pred_df_total$tendencia






# 4. Convertir a raster y recortar al país (para predicción corregida con tendencia)
pred_raster <- rasterFromXYZ(pred_df_total[, c("x", "y", "PM25_estimado")])
colom_sp <- as(colom_shp, "Spatial")
pred_raster_masked <- mask(pred_raster, colom_sp)

# 5. Convertir a raster y recortar al país (para varianza del cokriging)
var_raster <- raster(pred["PM2.5.var"])
var_raster_masked <- mask(var_raster, colom_sp)

# 6. Convertir a data.frame para ggplot
pred_df <- as.data.frame(pred_raster_masked, xy = TRUE)
names(pred_df)[3] <- "PM25_estimado"
pred_df <- na.omit(pred_df)

var_df <- as.data.frame(var_raster_masked, xy = TRUE)
var_df <- na.omit(var_df)

# 7. Visualizar la predicción puntual (concentración total)
gr7 <- ggplot() +
  geom_raster(data = pred_df, aes(x = x, y = y, fill = PM25_estimado)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = expression("PM2.5 estimado (µg/"*m^3*")"),
    limits = c(min(pred_df$PM25_estimado, na.rm = TRUE),
               max(pred_df$PM25_estimado, na.rm = TRUE)),
    colours = c("blue", "cyan", "green", "yellow", "orange", "red")
  ) +
  labs(
    title = "Concentración estimada de PM2.5 (µg/m³)",
    subtitle = "Tendencia + Cokriging de residuos (con PM10)",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

# 8. Visualizar la varianza (incertidumbre del cokriging)
gr8 <- ggplot() +
  geom_raster(data = var_df, aes(x = x, y = y, fill = PM2.5.var)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradient(
    name = "Varianza\nPM2.5",
    low = "white",
    high = "darkred"
  ) +
  labs(
    title = "Varianza estimada de la predicción de PM2.5",
    subtitle = "Cokriging de residuos",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr7)

print(gr8)

# summary(var_df$PM2.5.var)




# 9. Calcular el Coeficiente de Variación (CV) en el dataframe
cv_df <- data.frame(
  x = pred_df$x,
  y = pred_df$y,
  CV = (sqrt(var_df$PM2.5.var) / pred_df$PM25_estimado) * 100
)

# Evitar valores infinitos o NA por división cerca de cero
cv_df$CV[is.infinite(cv_df$CV) | is.nan(cv_df$CV)] <- NA
cv_df <- na.omit(cv_df)

# 10. Graficar el Coeficiente de Variación (%)
gr9 <- ggplot() +
  geom_raster(data = cv_df, aes(x = x, y = y, fill = CV)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Coeficiente de Variación (%)",
    colours = c("white", "yellow", "orange", "red", "darkred"),
    na.value = NA
  ) +
  labs(
    title = "Mapa del Coeficiente de Variación (CV) de PM2.5",
    subtitle = "Incertidumbre relativa (Desv. estándar / Estimado) * 100",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr9)
```

El mapa de la varianza de predicción del Cokriging presenta una superficie más suave y continua en comparación con la obtenida en el análisis univariado, sin los picos abruptos que aparecían sobre las estaciones de monitoreo. Los valores de varianza estimada oscilan entre 0 y 6-7 $\mu g/m^3$, y se observa un patrón creciente de norte a sur, siendo especialmente elevada en el extremo sur de la ciudad, en zonas como Usme y su periferia rural, donde históricamente se dispone de menor densidad de estaciones. Este patrón está en línea con la lógica geográfica y operativa del monitoreo: las zonas menos urbanizadas y de más difícil acceso tienden a tener mayor incertidumbre en las estimaciones debido a la escasa disponibilidad de datos directos.

Respecto al coeficiente de variación de las predicciones, se evidencia un cambio importante frente al modelo univariado. Mientras anteriormente las zonas de mayor incertidumbre relativa se ubicaban en el oriente, en este caso el mayor coeficiente de variación (hasta 17%) se concentra en la región suroriente, posiblemente como consecuencia de la variabilidad espacial más compleja del PM10 en esa zona, que se transfiere al estimador del PM2.5. Por su parte, la zona occidental de la ciudad, donde se detectaron las mayores concentraciones de PM2.5, presenta ahora los valores más bajos de coeficiente de variación (alrededor del 4-5%), lo cual da mayor confiabilidad a los resultados en las áreas donde más se requiere una estimación precisa.

```{r}
#| echo: false
library(gstat)
library(sp)
library(knitr)

# Asegurar sistema de referencia (solo si no tiene)
if (is.na(proj4string(df_ok))) {
  proj4string(df_ok) <- CRS(st_crs(colom_shp)$wkt)
}

# 1. Validación cruzada Leave-One-Out para PM2.5 (modelo LMC ajustado)
cv_lmc <- krige.cv(PM2.5 ~ 1,
                   locations = df_ok,
                   model = lmc$model$PM2.5,
                   nfold = nrow(df_ok))  # Leave-One-Out

# 2. Convertir resultados a data.frame
cv_lmc_df <- as.data.frame(cv_lmc)

# 3. Calcular errores
cv_lmc_df$error <- cv_lmc_df$observed - cv_lmc_df$var1.pred

# 4. Métricas de validación
ME_lmc   <- mean(cv_lmc_df$error)
MAE_lmc  <- mean(abs(cv_lmc_df$error))
RMSE_lmc <- sqrt(mean(cv_lmc_df$error^2))

# 5. Tabla resumen con kable
errores_lmc <- data.frame(
  Métrica = c("Error Medio (ME)", 
              "Error Absoluto Medio (MAE)", 
              "Raíz del Error Cuadrático Medio (RMSE)"),
  Valor = round(c(ME_lmc, MAE_lmc, RMSE_lmc), 4)
)

k3 <- knitr::kable(errores_lmc, caption = "Resumen de medidas de calidad asociadas para el cokriging de PM2.5")
k1
k3



```

Finalmente, al comparar las medidas de calidad asociadas a las predicciones, se evidencia una mejora sustancial al aplicar Co-Kriging en lugar de Kriging univariado. El Error Medio (ME) pasó de -0.1841 en el modelo univariado a -0.0839 con Co-Kriging, lo que indica una reducción del sesgo. Asimismo, el Error Absoluto Medio (MAE) disminuyó de 4.4597 a 1.9606, y la Raíz del Error Cuadrático Medio (RMSE) bajó de 5.3882 a 2.2845, lo que refleja una mejora significativa en la precisión general del modelo. Estos resultados confirman que incorporar información del PM10 como variable auxiliar permite estimaciones del PM2.5 mucho más precisas, lo cual es especialmente útil en zonas donde las mediciones directas son escasas o ausentes.

# COKRIGING PM10

En el caso del Co-Kriging del PM10 utilizando el PM2.5 como variable auxiliar, se siguió una metodología análoga a la empleada previamente. Los semivariogramas individuales y cruzados resultaron prácticamente idénticos a los obtenidos en la predicción del PM2.5, lo cual es esperado dado que ambas variables comparten patrones espaciales similares. Nuevamente se optó por ajustar un Modelo Lineal de Coregionalización (LMC) con estructura gaussiana y rango inicial de 10.000, obteniéndose buenos ajustes en las estructuras individuales y cruzadas. Los modelos lograron capturar adecuadamente la dependencia espacial, siendo consistentes con el comportamiento observado en los semivariogramas empíricos.

## Cálculo de los semivariogramas empíricos

```{r}
#| echo: false

df <- merge(PM2_5[,c(1,2,6)], PM10[,c(1,2,6)], by = c("este", "norte"), all = TRUE)
colnames(df)[3:4] <- c("PM2.5", "PM10")  # usa los nombres que usará gstat
# 
# cor(df, use = "complete.obs")
# 
# summary(dist(df[,1:2]))


coordinates(df) <- ~este + norte

# summary(df)

df_ok <- df[!is.na(df$PM2.5) & !is.na(df$PM10), ]

# Define modelo gstat para cada variable
g <- gstat(NULL, id = "PM10", formula = PM10 ~ 1, data = df_ok)
g <- gstat(g,    id = "PM2.5", formula = PM2.5 ~ 1, data = df_ok)

# Calcula los variogramas directos y cruzado
# v <- variogram(g, cutoff = 14000, width = 1000)
v <- variogram(g, cutoff=14750, width = 1050)

v_filtrado <- v[v$np >= 5, ]
plot(v_filtrado, main = "Variogramas cruzados PM2.5 y PM10")
# 



```

## Ajuste del modelo teórico

```{r}
#| echo: false
calcular_rmse_lmc <- function(ajuste_lmc, v_filtrado) {
  modelo_PM10 <- ajuste_lmc$model$PM10
  modelo_PM25 <- ajuste_lmc$model$PM2.5
  modelo_cross <- ajuste_lmc$model$PM10.PM2.5
  
  v_PM10 <- subset(v_filtrado, id == "PM10")
  v_PM25 <- subset(v_filtrado, id == "PM2.5")
  v_cross <- subset(v_filtrado, id == "PM10.PM2.5")
  
  pred_PM10 <- variogramLine(modelo_PM10, dist_vector = v_PM10$dist)
  pred_PM25 <- variogramLine(modelo_PM25, dist_vector = v_PM25$dist)
  pred_cross <- variogramLine(modelo_cross, dist_vector = v_cross$dist)
  
  rmse_PM10 <- sqrt(mean((v_PM10$gamma - pred_PM10$gamma)^2))
  rmse_PM25 <- sqrt(mean((v_PM25$gamma - pred_PM25$gamma)^2))
  rmse_cross <- sqrt(mean((v_cross$gamma - pred_cross$gamma)^2))
  
  mean(c(rmse_PM10, rmse_PM25, rmse_cross))
}

ajustar_y_evaluar_modelos <- function(v_filtrado, g, modelos_base) {
  resultados <- data.frame(Modelo = character(), RMSE = numeric(), stringsAsFactors = FALSE)
  
  for (nombre in names(modelos_base)) {
    modelo_inicial <- modelos_base[[nombre]]
    ajuste <- tryCatch({
      fit.lmc(v_filtrado, g, model = modelo_inicial)
    }, error = function(e) NULL)
    
    if (!is.null(ajuste)) {
      rmse <- calcular_rmse_lmc(ajuste, v_filtrado)
      resultados <- rbind(resultados, data.frame(Modelo = nombre, RMSE = rmse))
    }
  }
  
  resultados <- resultados[order(resultados$RMSE), ]
  return(resultados)
}

# Define tus modelos base, por ejemplo:
modelos_base <- list(
  Exp6000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 6000),
  Exp7000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 7000),
  Exp8000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 8000),
  Exp9000 = vgm(psill = 5, model = "Exp", nugget = 0.0, range = 9000),
  Sph6000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 6000),
  Sph7000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 7000),
  Sph8000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 8000),
  Sph9000 = vgm(psill = 5, model = "Sph", nugget = 0.0, range = 9000),
  Gau6000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 6000),
  Gau7000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 7000),
  Gau8000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 8000),
  Gau9000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 9000),
  Gau10000 = vgm(psill = 5, model = "Gau", nugget = 0.0, range = 10000)
)
```

```{r}
#| echo: false
# Corre la comparación:
resultados <- ajustar_y_evaluar_modelos(v_filtrado, g, modelos_base)
print(resultados)
```

```{r}
#| echo: false
# Define el modelo con estructura esférica
model <- vgm(psill = 20, model = "Gau", nugget = 0, range = 10000)

# Ajusta el modelo a los tres variogramas
lmc <- fit.lmc(v_filtrado, g, model = model)

# Guardar sill totales antes de modificar
sill_PM10_total <- sum(lmc$model$PM10$psill)
sill_PM25_total <- sum(lmc$model$PM2.5$psill)
sill_cross_total <- sum(lmc$model$`PM10.PM2.5`$psill)

# Nuggets diferentes para cada componente
nugget1 <- 5  # nugget PM10
nugget2 <- 0.5  # nugget PM2.5
nugget3 <- 0  # nugget cruzado

# Asignar nuggets
lmc$model$PM10$psill[1] <- nugget1
lmc$model$PM2.5$psill[1] <- nugget2
lmc$model$`PM10.PM2.5`$psill[1] <- nugget3

# Ajustar sill gaussiano para mantener el sill total igual al original
lmc$model$PM10$psill[2] <- sill_PM10_total - nugget1
lmc$model$PM2.5$psill[2] <- sill_PM25_total - nugget2
lmc$model$`PM10.PM2.5`$psill[2] <- sill_cross_total - nugget3


# Visualiza el ajuste
plot(v_filtrado, lmc, main = "Ajuste del modelo LMC")

```

## Predicciones para el PM2.5 usando cokriging

En cuanto al mapa de predicción de PM10, se evidenció un patrón muy similar al encontrado en el caso univariado: valores más bajos (alrededor de 30) en el oriente y nororiente de la ciudad, y valores crecientes hacia el occidente, alcanzando incluso concentraciones superiores a 70. La varianza de predicción fue menor en las zonas donde se ubican las estaciones de monitoreo (zonas centrales y norte), y más alta en regiones rurales y periféricas como Usme, donde supera los 25. El coeficiente de variación se mantuvo en un rango de 0 a 20%, reflejando un patrón muy parecido al observado en el Cokriging del PM2.5, con mayor incertidumbre en las zonas periféricas y más certeza en los sectores más contaminados del occidente. Sin embargo, al comparar las medidas de error, se observa que el Co-Kriging para PM10 no mejora respecto al modelo univariado, ya que el RMSE aumentó de 5.3882 a 5.7235 y el MAE también se incrementó levemente. Esto sugiere que, en este caso, el PM2.5 no aporta información adicional suficiente para mejorar la predicción del PM10, probablemente porque el PM10 tiene una variabilidad propia más alta o más ruido en su medición.

```{r}
#| echo: false
#| message: false
#| warning: false

# 0. Crear el objeto gstat con modelos ajustados desde LMC
g_cokrig <- gstat(NULL, id = "PM2.5", formula = PM2.5 ~ 1, data = df_ok, model = lmc$model$PM2.5)
g_cokrig <- gstat(g_cokrig, id = "PM10", formula = PM10 ~ 1, data = df_ok, model = lmc$model$PM10)
g_cokrig <- gstat(g_cokrig, id = c("PM2.5", "PM10"), model = lmc$model$PM10.PM2.5)


# 1. Crear grilla basada en el shapefile
bbox_colom <- st_bbox(colom_shp)
grilla <- expand.grid(
  x = seq(bbox_colom["xmin"], bbox_colom["xmax"], by = 100),
  y = seq(bbox_colom["ymin"], bbox_colom["ymax"], by = 100)
)

#496980.4

coordinates(grilla) <- ~x + y
gridded(grilla) <- TRUE
proj4string(grilla) <- CRS(st_crs(df_ok)$wkt)  # CRS consistente con los datos de entrenamiento

# 2. Predecir con cokriging (predicción y varianza)
pred <- predict(g_cokrig, newdata = grilla)





# 1. Convertir a dataframe
pred_df_total <- as.data.frame(pred, xy = TRUE)
pred_df_total <- na.omit(pred_df_total)

# 2. Crear variables necesarias para la tendencia (deben ser iguales a las del modelo fit1)
pred_df_total$este <- pred_df_total$x
pred_df_total$este2 <- pred_df_total$este^2  # si tu modelo tenía términos cuadráticos, ajusta según sea necesario

# 3. Predecir la tendencia con el modelo ajustado
pred_df_total$tendencia <- predict(fit2, newdata = pred_df_total)

# 4. Sumar tendencia + cokriging de residuos
pred_df_total$PM10_estimado <- pred_df_total$PM10.pred + pred_df_total$tendencia






# 4. Convertir a raster y recortar al país (para predicción corregida con tendencia)
pred_raster <- rasterFromXYZ(pred_df_total[, c("x", "y", "PM10_estimado")])
colom_sp <- as(colom_shp, "Spatial")
pred_raster_masked <- mask(pred_raster, colom_sp)

# 5. Convertir a raster y recortar al país (para varianza del cokriging)
var_raster <- raster(pred["PM10.var"])
var_raster_masked <- mask(var_raster, colom_sp)

# 6. Convertir a data.frame para ggplot
pred_df <- as.data.frame(pred_raster_masked, xy = TRUE)
names(pred_df)[3] <- "PM10_estimado"
pred_df <- na.omit(pred_df)

var_df <- as.data.frame(var_raster_masked, xy = TRUE)
var_df <- na.omit(var_df)

# 7. Visualizar la predicción puntual (concentración total)
gr10 <- ggplot() +
  geom_raster(data = pred_df, aes(x = x, y = y, fill = PM10_estimado)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = expression("PM10 estimado (µg/"*m^3*")"),
    limits = c(min(pred_df$PM10_estimado, na.rm = TRUE),
               max(pred_df$PM10_estimado, na.rm = TRUE)),
    colours = c("blue", "cyan", "green", "yellow", "orange", "red")
  ) +
  labs(
    title = "Concentración estimada de PM10 (µg/m³)",
    subtitle = "Tendencia + Cokriging de residuos (con PM2.5)",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

# 8. Visualizar la varianza (incertidumbre del cokriging)
gr11 <- ggplot() +
  geom_raster(data = var_df, aes(x = x, y = y, fill = PM10.var)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradient(
    name = "Varianza\nPM10",
    low = "white",
    high = "darkred"
  ) +
  labs(
    title = "Varianza estimada de la predicción de PM10",
    subtitle = "Cokriging de residuos",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr10)

print(gr11)

# summary(var_df$PM10.var)




# 9. Calcular el Coeficiente de Variación (CV) en el dataframe
cv_df <- data.frame(
  x = pred_df$x,
  y = pred_df$y,
  CV = (sqrt(var_df$PM10.var) / pred_df$PM10_estimado) * 100
)

# Evitar valores infinitos o NA por división cerca de cero
cv_df$CV[is.infinite(cv_df$CV) | is.nan(cv_df$CV)] <- NA
cv_df <- na.omit(cv_df)

# 10. Graficar el Coeficiente de Variación (%)
gr12 <- ggplot() +
  geom_raster(data = cv_df, aes(x = x, y = y, fill = CV)) +
  geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
  scale_fill_gradientn(
    name = "Coeficiente de Variación (%)",
    colours = c("white", "yellow", "orange", "red", "darkred"),
    na.value = NA
  ) +
  labs(
    title = "Mapa del Coeficiente de Variación (CV) de PM10",
    subtitle = "Incertidumbre relativa (Desv. estándar / Estimado) * 100",
    caption = "Modelo Gaussiano ajustado con LMC"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  ) +
  coord_sf()

print(gr12)
```

```{r}
#| echo: false
library(gstat)
library(sp)
library(knitr)

# Asegurar sistema de referencia (solo si no tiene)
if (is.na(proj4string(df_ok))) {
  proj4string(df_ok) <- CRS(st_crs(colom_shp)$wkt)
}

# 1. Validación cruzada Leave-One-Out para PM2.5 (modelo LMC ajustado)
cv_lmc <- krige.cv(PM10 ~ 1,
                   locations = df_ok,
                   model = lmc$model$PM10,
                   nfold = nrow(df_ok))  # Leave-One-Out

# 2. Convertir resultados a data.frame
cv_lmc_df <- as.data.frame(cv_lmc)

# 3. Calcular errores
cv_lmc_df$error <- cv_lmc_df$observed - cv_lmc_df$var1.pred

# 4. Métricas de validación
ME_lmc   <- mean(cv_lmc_df$error)
MAE_lmc  <- mean(abs(cv_lmc_df$error))
RMSE_lmc <- sqrt(mean(cv_lmc_df$error^2))

# 5. Tabla resumen con kable
errores_lmc <- data.frame(
  Métrica = c("Error Medio (ME)", 
              "Error Absoluto Medio (MAE)", 
              "Raíz del Error Cuadrático Medio (RMSE)"),
  Valor = round(c(ME_lmc, MAE_lmc, RMSE_lmc), 4)
)

k4 <- knitr::kable(errores_lmc, caption = "Resumen de medidas de calidad asociadas para el cokriging de PM10")
k2
k4



```

```{r}
#| eval: false
#| include: false
#################################################################
######### Modelo lineal de corregionalización sin Gstat #########
#################################################################

# Variogramas directos y cruzados
calcular_variogramas <- function(datos, cutoff, width) {
  n_puntos <- nrow(datos)
  coords <- datos@coords
  var1 <- datos@data$PM10
  var2 <- datos@data$PM2.5
  
  # Matriz de distancias
  matriz_dist <- as.matrix(dist(coords))
  
  # Limites
  lags_limites <- seq(0, cutoff, by = width)
  n_lags <- length(lags_limites) - 1
  
  # Resultados por lag
  acumulador <- lapply(1:n_lags, function(i) {
    list(
      suma_diff_dir1 = 0,
      suma_diff_dir2 = 0,
      suma_prod_cruz = 0,
      num_pares = 0
    )
  })
  
  for (i in 1:(n_puntos - 1)) {
    for (j in (i + 1):n_puntos) {
      
      # Distancia
      distancia_ij <- matriz_dist[i, j]
      
      # Cutoff
      if (distancia_ij > cutoff) {
        next
      }
      
      # Pertenencia lag
      lag_idx <- findInterval(distancia_ij, lags_limites)
      
      if (lag_idx == 0 || lag_idx > n_lags) {
        next
      }
      
      # Diferencias al cuadrado y el producto
      diff1 <- var1[i] - var1[j]
      diff2 <- var2[i] - var2[j]
      
      sq_diff_dir1 <- diff1^2
      sq_diff_dir2 <- diff2^2
      prod_diff_cruz <- diff1 * diff2
      
      # Valores de los lags
      acumulador[[lag_idx]]$suma_diff_dir1 <- acumulador[[lag_idx]]$suma_diff_dir1 + sq_diff_dir1
      acumulador[[lag_idx]]$suma_diff_dir2 <- acumulador[[lag_idx]]$suma_diff_dir2 + sq_diff_dir2
      acumulador[[lag_idx]]$suma_prod_cruz <- acumulador[[lag_idx]]$suma_prod_cruz + prod_diff_cruz
      acumulador[[lag_idx]]$num_pares <- acumulador[[lag_idx]]$num_pares + 1
    }
  }
  
  # Calculo de valores
  resultado_final <- lapply(1:n_lags, function(k) {
    lag_data <- acumulador[[k]]
    
    if (lag_data$num_pares == 0) {
      return(NULL)
    }
    
    # Estimador de Matheron
    gamma_dir1 <- lag_data$suma_diff_dir1 / (2 * lag_data$num_pares)
    gamma_dir2 <- lag_data$suma_diff_dir2 / (2 * lag_data$num_pares)
    gamma_cruz <- lag_data$suma_prod_cruz / (2 * lag_data$num_pares)
    
    # Distancia representativa
    dist_media <- (lags_limites[k] + lags_limites[k+1]) / 2
    
    data.frame(
      dist = dist_media,
      gamma_dir1 = gamma_dir1,
      gamma_dir2 = gamma_dir2,
      gamma_cruz = gamma_cruz,
      np = lag_data$num_pares
    )
  })
  
  # Combinar los resultados
  resultado_df <- do.call(rbind, resultado_final)
  
  output_list <- list(
    directo1 = data.frame(dist = resultado_df$dist, 
                          gamma = resultado_df$gamma_dir1, 
                          np = resultado_df$np),
    directo2 = data.frame(dist = resultado_df$dist, 
                          gamma = resultado_df$gamma_dir2, 
                          np = resultado_df$np),
    cruzado  = data.frame(dist = resultado_df$dist, 
                          gamma = resultado_df$gamma_cruz, 
                          np = resultado_df$np)
  )
  
  return(output_list)
}

# Semivariogramas directos y cruzados
variogramases <- calcular_variogramas(
  datos = df_ok,
  cutoff = 15707.75,   
  width = 1208.288     
)

# # Visualizar los resultados
par(mfrow=c(2,2), mar = c(4, 4, 2, 1))
plot(variogramases$directo1$dist, variogramases$directo1$gamma, 
     xlab = "Distancia", ylab = "Semivarianza", main = "PM10", pch = 16,
     ylim = c(min(0, min(variogramases$directo1$gamma)), 
              max(variogramases$directo1$gamma) * 1.1))
plot(variogramases$directo2$dist, variogramases$directo2$gamma, 
     xlab = "Distancia", ylab = "Semivarianza", main = "PM2.5", pch = 16,
     ylim = c(min(0, min(variogramases$directo2$gamma)), 
              max(variogramases$directo2$gamma) * 1.1))
plot(variogramases$cruzado$dist, variogramases$cruzado$gamma, 
     xlab = "Distancia", ylab = "Semivarianza Cruzada", main = "Cruzado",
     pch = 16, ylim = c(min(0, min(variogramases$cruzado$gamma)), 
                        max(variogramases$cruzado$gamma) * 1.1))


modelo_lmc_gauss <- function(params, h) {
  b11_gau <- params[1]
  b12_gau <- params[2]
  b22_gau <- params[3]
  range_gau <- params[4]
  
  # Validez del modelo
  valido_gau <- (b11_gau>=0)&&(b22_gau>=0)&&((b11_gau*b22_gau-b12_gau^2) >= 0)
  
  if (!valido_gau) {
    return(list(gamma11 = rep(Inf, length(h)), 
                gamma22 = rep(Inf, length(h)), 
                gamma12 = rep(Inf, length(h))))
  }
  
  # Modelo Gaussiano
  cov_gau <- geoR::cov.spatial(h, cov.model = "gaussian", 
                               cov.pars = c(1, range_gau))
  gamma_gau <- 1 - cov_gau
  
  # semivariogramas teóricos
  gamma11_teorico <- b11_gau * gamma_gau
  gamma22_teorico <- b22_gau * gamma_gau
  gamma12_teorico <- b12_gau * gamma_gau
  
  return(list(gamma11 = gamma11_teorico, 
              gamma22 = gamma22_teorico, 
              gamma12 = gamma12_teorico))
}


valores_iniciales_gau <- c(
  b11_gau = 0.20,     
  b12_gau = 0.10,     
  b22_gau = 0.20,    
  range_gau = 8000
)

objetivo_wls <- function(params, variogramas_empiricos, modelo_func) {
  v_dir1_emp <- variogramas_empiricos$directo1
  v_dir2_emp <- variogramas_empiricos$directo2
  v_cruz_emp <- variogramas_empiricos$cruzado
  
  gamma_teorico <- modelo_func(params, h = v_dir1_emp$dist)
  
  if (is.infinite(gamma_teorico$gamma11[1])) {
    return(1e10)
  }
  
  error_sq_dir1 <- (v_dir1_emp$gamma - gamma_teorico$gamma11)^2
  error_sq_dir2 <- (v_dir2_emp$gamma - gamma_teorico$gamma22)^2
  error_sq_cruz <- (v_cruz_emp$gamma - gamma_teorico$gamma12)^2
  
  peso_dir1 <- v_dir1_emp$np
  peso_dir2 <- v_dir2_emp$np
  peso_cruz <- v_cruz_emp$np
  
  wsse <- sum(peso_dir1 * error_sq_dir1) + 
    sum(peso_dir2 * error_sq_dir2) + 
    sum(peso_cruz * error_sq_cruz)
  
  return(wsse)
}


ajustar_lmc <- function(variogramas_empiricos, 
                        valores_iniciales, modelo_func) {
  num_params <- length(valores_iniciales)
  
  limites_inf <- rep(0, num_params)
  limites_inf[c(2)] <- -Inf
  limites_sup <- rep(Inf, num_params)
  
  resultado_opt <- optim(
    par = valores_iniciales,
    fn = objetivo_wls,
    variogramas_empiricos = variogramas_empiricos,
    modelo_func = modelo_func,
    method = "L-BFGS-B",
    lower = limites_inf,
    upper = limites_sup,
    control = list(trace = 1, maxit = 1000)
  )
  
  return(resultado_opt)
}


ajuste_gauss <- ajustar_lmc(
  variogramas_empiricos = variogramases,
  valores_iniciales = valores_iniciales_gau,
  modelo_func = modelo_lmc_gauss
)

parametros_optimos_gau <- ajuste_gauss$par

v_pm10_emp <- variogramases$directo1
v_pm25_emp <- variogramases$directo2
v_cruzado_emp <- variogramases$cruzado

dist_teorica <- seq(0, 22000, length.out = 200)
curvas_ajustadas_puro <- modelo_lmc_gauss(parametros_optimos_gau, 
                                          h = dist_teorica)
par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))

plot(v_pm10_emp$dist, v_pm10_emp$gamma, 
     xlab = "Distancia", ylab = "Semivarianza",
     main = "PM10", pch = 16,
     ylim = c(0, max(v_pm10_emp$gamma) * 1.1))
grid()
lines(dist_teorica, curvas_ajustadas_puro$gamma11, lwd = 2)

plot(v_pm25_emp$dist, v_pm25_emp$gamma, 
     xlab = "Distancia", ylab = "Semivarianza",
     main = "PM2.5", pch = 16,
     ylim = c(0, max(v_pm25_emp$gamma) * 1.1))
grid()
lines(dist_teorica, curvas_ajustadas_puro$gamma22, lwd = 2)

plot(v_cruzado_emp$dist, v_cruzado_emp$gamma,
     xlab = "Distancia", ylab = "Semivarianza Cruzada",
     main = "Cruzado", pch = 16,
     ylim = c(min(0, min(v_cruzado_emp$gamma)), max(v_cruzado_emp$gamma) * 1.1))
grid()
lines(dist_teorica, curvas_ajustadas_puro$gamma12, lwd = 2)
```

# CONCLUSIONES GENERALES

Este análisis abordó de forma integral la caracterización espacial de la calidad del aire en Bogotá durante el año 2022, enfocándose en los contaminantes PM2.5 y PM10. A través de un enfoque geoestadístico riguroso, que incluyó desde análisis exploratorio y extracción de tendencias hasta el ajuste de modelos de semivariogramas y la aplicación de Kriging y Co-Kriging, fue posible identificar patrones de distribución, niveles de incertidumbre y áreas críticas de concentración de contaminantes en la ciudad.

Desde el punto de vista metodológico, se demostró la importancia de remover tendencias espaciales antes de aplicar métodos de interpolación, lo cual permitió mejorar la precisión de las predicciones. El uso del Co-Kriging, en particular, evidenció su utilidad cuando se cuenta con variables auxiliares correlacionadas, como ocurrió al predecir PM2.5 apoyándose en PM10, donde los errores de predicción se redujeron notablemente. En cambio, al invertir la relación (PM10 explicado con PM2.5), la mejora no fue tan significativa, posiblemente debido a la mayor variabilidad propia del PM10 o a diferencias en la dinámica de su emisión.

En términos de resultados reales, se identificó una clara concentración de contaminantes hacia el occidente de Bogotá, en especial en localidades con alta densidad poblacional, tráfico vehicular e industrias. Por el contrario, las zonas nororientales y surorientales —más cercanas a los cerros orientales o con menor actividad urbana— mostraron niveles considerablemente más bajos de contaminación. Esta distribución no es casual: responde a factores estructurales como la ubicación de fuentes emisoras, la topografía, la dirección de los vientos y las brechas en infraestructura ambiental, como la baja densidad de estaciones en ciertas zonas rurales o periféricas.

Los mapas de incertidumbre también revelaron que, mientras las zonas cercanas a estaciones tienen predicciones más confiables, otras regiones —especialmente en el suroriente— presentan alta incertidumbre, lo que sugiere la necesidad de reforzar el monitoreo en esos sectores para garantizar una cobertura equitativa y eficaz en el control ambiental.

En conjunto, este estudio no solo permitió describir la calidad del aire con gran detalle, sino también identificar zonas prioritarias para la intervención y sentar bases técnicas sólidas para futuras decisiones en salud pública, planeación urbana y justicia ambiental. Además, deja en evidencia que, con una buena estrategia de modelación espacial, es posible ampliar el conocimiento más allá de los puntos medidos, cubriendo vacíos críticos para la gestión territorial sostenible.

# ANÁLISIS ESPACIO - TEMPORAL PM2.5

El siguiente análisis corresponde al contaminante PM2.5 en la ciudad de Bogotá durante el período comprendido entre 2020 y 2021. Se cuenta con datos diarios recogidos en 19 estaciones de monitoreo distribuidas a lo largo de la ciudad. El objetivo principal de este estudio es realizar un análisis espacio-temporal para caracterizar la distribución y variabilidad de las concentraciones de PM2.5. Para ello, se empleará la técnica de interpolación geoestadística de kriging espacial, que permitirá estimar los niveles de este contaminante en áreas no monitoreadas y generar mapas de distribución que faciliten la identificación de las zonas más afectadas y los patrones de dispersión a lo largo del tiempo.

```{r}
#| echo: false
#| message: false
#| warning: false
colom_shp <- suppressMessages(st_read("mapa/loca.shp"))  # Ocultar mensajes de st_read
colom_shp <- st_transform(colom_shp[-9,], crs = "+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs")



CRS_UTM_CO <- CRS("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs")


PM2_5 <- read_xlsx("PM2_5.xlsx")

# Para PM2.5
PM2_5_sf <- st_as_sf(PM2_5, coords = c("este", "norte"), crs = CRS_UTM_CO)

ggplot() +
  geom_sf(data = colom_shp, fill = "white", color = "black") +
  geom_sf(data = PM2_5_sf, aes(color = PM2.5), alpha = 0.8) +
  scale_color_gradient(name = "PM2.5 (µg/m³)", low = "blue", high = "red") +
  labs(title = "Mapa de estaciones PM2.5 - Bogotá") +
  theme_minimal()
```

## Exploración de la relación entre PM2.5, las coordenadas espaciales y temporalidad

Para iniciar el análisis, se realizó una exploración visual de los datos de PM2.5. Se generaron gráficos de dispersión para examinar la relación entre las concentraciones de PM2.5 y sus coordenadas espaciales (Este y Norte), así como su evolución a lo largo del tiempo.

```{r}
#| echo: false
#| message: false
#| warning: false
# Gráfico 1: PM2.5 vs Este
p1 <- ggplot(PM2_5, aes(x = este, y = PM2.5)) +
  geom_point(color = "blue") +
  labs(title = "PM2.5 vs Este", x = "Este (X)", y = "PM2.5") +
  theme_minimal()

# Gráfico 2: PM2.5 vs Norte
p2 <- ggplot(PM2_5, aes(x = norte, y = PM2.5)) +
  geom_point(color = "blue") +
  labs(title = "PM2.5 vs Norte", x = "Norte (Y)", y = "PM2.5") +
  theme_minimal()

# Gráfico 3: PM2.5 vs Fecha
p3 <- ggplot(PM2_5, aes(x = fecha, y = PM2.5)) +
  geom_point(color = "darkred", alpha = 0.5) +
  labs(title = "PM2.5 a lo largo del tiempo", x = "Fecha", y = "PM2.5") +
  theme_minimal()

# Unir los tres gráficos en un solo panel
(p1 | p2) / p3

```

La figura presenta tres gráficos que ilustran las relaciones iniciales en los datos. Los dos gráficos superiores muestran la concentración de PM2.5 ​ frente a las coordenadas geográficas (Este y Norte), en el cual no se observa una tendencia lineal clara sin embargo, los datos se presentan en conglomerados verticales, que corresponden a las ubicaciones fijas de las estaciones de monitoreo. Se aprecian variaciones significativas en los niveles de PM2.5 ​ en cada una de estas ubicaciones, lo que sugiere que la contaminación no es homogénea en la ciudad y justifica el uso de métodos de interpolación espacial como el kriging. El gráfico inferior muestra la serie temporal de las mediciones de PM2.5, en dicho gráfico se puede identificar un patrón estacional. Los niveles de PM2.5 ​ parecen ser más bajos y estables durante noviembre y diciembre, mientras que se observa un incremento general en las concentraciones y en la frecuencia de picos elevados durante enero y, especialmente, febrero. Este comportamiento se puede explicar por las condiciones meteorológicas de Bogotá, donde los primeros meses del año suelen ser más secos, favoreciendo la acumulación de contaminantes.

## Ajuste del modelo de tendencia mediante regresión

Se ajusto un modelo de regresión lineal para describir cómo las concentraciones de PM2.5 ​ varían en función de su ubicación geográfica. El modelo contemplado es el siguiente:

$$
PM2.5 = \beta_0+\beta_1\cdot este + \beta_2\cdot norte+\beta_3\cdot \sin(este)+\beta_4\cdot\sin(norte)
$$

```{r}
#| echo: false
#| message: false
#| warning: false
fit1 <- lm(PM2.5 ~ sin(este) + sin(norte)+este+norte, data = PM2_5)
tidy_fit <- tidy(fit1)
kable(tidy_fit, digits = 4, caption = "Resumen del modelo lineal")
```

## Análisis gráfico de los residuos estandarizados

```{r}
#| echo: false
#| message: false
#| warning: false
PM2_5$residuales <- residuals(fit1)

res1 <- PM2_5$residuales
par(mfrow = c(1, 3))

# Residuales estandarizados vs Coordenada Este
plot(PM2_5$este, res1,
     main = "Residuales vs Coordenada Este",
     xlab = "Este",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkblue")

# Residuales estandarizados vs Coordenada Norte
plot(PM2_5$norte, res1,
     main = "Residuales vs Coordenada Norte",
     xlab = "Norte",
     ylab = "Residuales estandarizados",
     pch = 16, col = "darkgreen")

# Boxplot de los residuales estandarizados
boxplot(res1,
        main = "Distribución de Residuales",
        ylab = "Residuales estandarizados",
        col = "red",
        ylim = c(-25, 25))

par(mfrow = c(1, 1))

PM2_5$residuals <- res1
```

El análisis de los residuales estandarizados respecto a las coordenadas Este y Norte muestra una distribución aleatoria sin patrones espaciales evidentes, lo que indica una correcta extracción de la tendencia. El diagrama de caja corrobora esto al presentar una dispersión centrada en cero; los valores atípicos observados se consideran parte de la variabilidad natural del fenómeno ambiental en estudio.

## Estimación del semivariograma

Para analizar la estructura de dependencia espacial y temporal de los residuales de PM2.5 ​, se procedió a calcular el variograma empírico espacio-temporal.

```{r}
#| echo: false
#| message: false
#| warning: false
# Preparar datos
PM2_5_clean <- PM2_5
PM2_5_clean$Fecha <- as.POSIXct(PM2_5$fecha)

# Convertir a SpatialPoints
coordinates(PM2_5_clean) <- ~este + norte

# Crear vectores de espacio y tiempo
spatial_points <- unique(PM2_5_clean@coords)  # puntos únicos
times <- sort(unique(PM2_5_clean$Fecha))      # tiempos únicos

# Crear SpatialPoints para la malla espacial
sp <- SpatialPoints(spatial_points)

# Crear data.frame con variable residuals ordenada para el STFDF:
# Primero, crear un data.frame vacío con filas = puntos espaciales, columnas = tiempos
# y rellenar con NA
residuals_matrix <- matrix(NA, nrow = length(sp), ncol = length(times),
                           dimnames = list(NULL, as.character(times)))

# Llenar residuals_matrix con los valores correspondientes
for (i in seq_len(nrow(PM2_5_clean))) {
  # Encontrar fila y columna
  point_index <- which(apply(sp@coords, 1, function(r) all(r == PM2_5_clean@coords[i, ])))
  time_index <- which(times == PM2_5_clean$Fecha[i])
  residuals_matrix[point_index, time_index] <- PM2_5_clean$residuals[i]
}

# Crear data.frame para STFDF (aplanar la matriz en un vector)
data_df <- data.frame(residuals = as.vector(residuals_matrix))

# Crear objeto STFDF
st_data <- STFDF(sp = sp, time = times, data = data_df)

# Ahora sí, calcular el variograma espaciotemporal
v_st <- variogramST(
  residuals ~ 1,
  data = st_data,
  tunit = "days",
  cutoff = 19000, #19000
  width = 2400, #2400
  tlags = 0:5,
  assumeRegular = TRUE
)
v_st <- subset(v_st, np > 0)


plot(v_st)

plot(v_st, wireframe = TRUE, colorkey = TRUE,
     main = "Semivariograma Espacio-temporal")
```

Este gráfico tridimensional ilustra la estructura de dependencia del PM2.5. La superficie ascendente muestra que la correlación entre mediciones se debilita a medida que aumenta la distancia o los días de separación.

### Ajuste de modelos teóricos al semivariograma empírico

A continuación se realizo el ajuste de modelos teóricos, se eligió un modelo inicial donde el componente espacial se usa un modelo "Hole" y el componente temporal un modelo Pentaesferico.

```{r}
#| echo: false
#| message: false
#| warning: false
# Definir modelo inicial del variograma espacio-temporal (ajustable)
model_init <- vgmST(
  "separable",
  space = vgm(psill = 40, model = "Hol", range = 6000, nugget = 0.1),
  time  = vgm(psill = 1, model = "Pen", range = 8, nugget = 0.1),
  sill  = 1
)

# Ajustar el modelo de variograma a los datos observados
model_fit <- fit.StVariogram(v_st, model_init, method = "L-BFGS-B")

plot(v_st,model_fit)

plot(v_st, model_fit, wireframe = TRUE, all = TRUE,
     colorkey = TRUE, main = "Ajuste del Modelo ST al Semivariograma Empírico")
```

## Kriging espacio tiempo de PM2.5

```{r}
#| echo: false
#| message: false
#| warning: false
# 1. Asegurarse de que el shapefile esté en CRS correcto
colom_shp <- st_transform(colom_shp, crs = CRS_UTM_CO)

# 2. Obtener bounding box del shapefile como objeto sf
bbox_colom <- st_bbox(colom_shp)

# 3. Crear malla de predicción en todo el país (en grilla regular)
x_range <- seq(bbox_colom["xmin"], bbox_colom["xmax"], by = 500)
y_range <- seq(bbox_colom["ymin"], bbox_colom["ymax"], by = 500)
grilla_espacio <- expand.grid(este = x_range, norte = y_range)

# 4. Convertir grilla a sf para filtrar solo puntos dentro de Colombia
grilla_sf <- st_as_sf(grilla_espacio, coords = c("este", "norte"), crs = CRS_UTM_CO)
grilla_dentro <- st_join(grilla_sf, colom_shp, join = st_within, left = FALSE)

# 5. Convertir de nuevo a Spatial (lo que requiere krigeST)
grilla_sp <- as(grilla_dentro, "Spatial")

gridded(grilla_sp) <- TRUE

# 6. Crear secuencia de tiempo
tiempos_pred <- seq(as.POSIXct("2020-10-16"), as.POSIXct("2021-03-31"), by = "10 days")

# 7. Malla espacio-temporal
grilla_st <- STF(sp = grilla_sp, time = tiempos_pred)

# EXTRA: Asegurar que el CRS de st_data@sp esté definido (si no lo tiene, asignarlo)
if (is.na(proj4string(st_data@sp))) {
  proj4string(st_data@sp) <- CRS_UTM_CO
}

# EXTRA: Asegurar que el CRS de st_data es el mismo que el de grilla_st
if (!identicalCRS(st_data@sp, grilla_sp)) {
  st_data@sp <- spTransform(st_data@sp, CRS_UTM_CO)
}
# 
gc()
# 8. Ejecutar kriging
kriging_result <- krigeST(
  residuals ~ 1,
  data = st_data,
  newdata = grilla_st,
  modelList = model_fit
)
gc()


graficar_kriging_con_tendencia <- function(fechas, kriging_result, fit1, colom_shp) {
  library(dplyr)
  library(ggplot2)
  
  # Paleta de 20 colores ordenados (oscuro a claro)
  colores_ordenados <- c(
    "#000000", "#2E0854", "#4B0082", "#0000CD", "#1E90FF",
    "#00CED1", "#00FF7F", "#7FFF00", "#ADFF2F", "#FFFF00",
    "#FFD700", "#FFA500", "#FF8C00", "#FF6347", "#FF4500",
    "#FF0000", "#DC143C", "#FF69B4", "#FFC0CB", "#FFFFFF"
  )
  
  fechas_xts <- index(kriging_result@time)
  
  # --- 1. Recolectar todos los valores PM25_estimado para calcular cuantiles ---
  todos_est <- data.frame()
  
  for (f in fechas) {
    fecha_objetivo <- as.POSIXct(f)
    if (!fecha_objetivo %in% fechas_xts) next
    kriging_en_fecha <- kriging_result[, fecha_objetivo]
    coords <- kriging_en_fecha@coords
    valores <- kriging_en_fecha@data$var1.pred
    df_tmp <- data.frame(x = coords[, 1], y = coords[, 2])
    df_tmp$este <- df_tmp$x
    df_tmp$norte <- df_tmp$y
    df_tmp$layer <- valores
    df_tmp$PM25_estimado <- df_tmp$layer + predict(fit1, newdata = df_tmp[, c("este", "norte")])
    todos_est <- bind_rows(todos_est, df_tmp)
  }
  
  # --- 2. Calcular los 20 cuantiles y etiquetas ---
  breaks <- quantile(todos_est$PM25_estimado, probs = seq(0, 1, length.out = 21), na.rm = TRUE)
  
  # Crear etiquetas del tipo "[a, b)"
  etiquetas <- sapply(1:20, function(i) {
    paste0("[", round(breaks[i], 1), ", ", round(breaks[i + 1], 1), ")")
  })
  
  # --- 3. Función para asignar tramo y color ---
  asignar_tramo <- function(valor) {
    idx <- findInterval(valor, breaks, rightmost.closed = TRUE, all.inside = TRUE)
    etiquetas[idx]
  }
  
  # --- 4. Graficar cada fecha ---
  for (f in fechas) {
    fecha_objetivo <- as.POSIXct(f)
    if (!fecha_objetivo %in% fechas_xts) {
      cat("Fecha no disponible:", f, "\n")
      next
    }
    
    cat("Graficando:", f, "\n")
    kriging_en_fecha <- kriging_result[, fecha_objetivo]
    coords <- kriging_en_fecha@coords
    valores <- kriging_en_fecha@data$var1.pred
    kriging_df <- data.frame(x = coords[, 1], y = coords[, 2], layer = valores)
    kriging_df$este <- kriging_df$x
    kriging_df$norte <- kriging_df$y
    kriging_df$PM25_estimado <- kriging_df$layer + predict(fit1, newdata = kriging_df[, c("este", "norte")])
    kriging_df <- na.omit(kriging_df)
    
    # Asignar tramo (cuantil) como factor
    kriging_df$tramo <- factor(asignar_tramo(kriging_df$PM25_estimado), levels = etiquetas)
    
    # Gráfico con leyenda manual

    p <- ggplot() +
      geom_point(data = kriging_df, aes(x = x, y = y, color = tramo), size = 1.8, alpha = 0.85) +
      scale_color_manual(
        values = setNames(colores_ordenados, etiquetas),
        name = "PM2.5 estimado (µg/m³)"
      ) +
      geom_sf(data = colom_shp, fill = NA, color = "black", linewidth = 0.3) +
      coord_sf() +
      labs(
        title = paste("PM2.5 estimado (por cuantiles) -", f),
        x = "Este", y = "Norte"
      ) +
      theme_minimal() +
      theme(
        legend.position = "right",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 10)
      )
    print(p)
    Sys.sleep(2)
  }
}

fechas_deseadas <- c(
  "2020-10-16", "2020-10-26", "2020-11-05", "2020-11-15",
  "2020-11-25", "2020-12-05", "2020-12-15", "2020-12-25",
  "2021-01-04", "2021-01-14", "2021-01-24", "2021-02-03",
  "2021-02-13", "2021-02-23", "2021-03-05", "2021-03-15"
)
```

::: panel-tabset
```{r}
#| label: mapas-pestañas
#| echo: false
#| results: 'asis'
#| warning: false
#| message: false

for (f in fechas_deseadas) {
  cat("### ", f, "\n\n")
  
  graficar_kriging_con_tendencia(f, kriging_result, fit1, colom_shp)
  
  cat("\n\n")
}
```
:::

Tras ajustar el modelo teórico separable al semivariograma espacio-temporal de los residuales y generar la malla de predicción (con celdas de 500 por 500 metros), se aplicó el método de kriging para estimar la evolución de los niveles de PM2.5 en toda la ciudad entre octubre de 2020 y marzo de 2021.

Los mapas resultantes revelan una marcada y persistente zonificación de la contaminación. Las zonas norte y nororiente de Bogotá, junto con el área de influencia de los Cerros Orientales, muestran consistentemente las concentraciones más bajas de PM2.5, representadas en tonos fríos. En contraste, el corredor suroccidental de la ciudad, que concentra alta densidad de tráfico y actividad industrial, presenta de forma sistemática los niveles más elevados. En estas zonas, representadas con tonos cálidos, las concentraciones superan con frecuencia los umbrales recomendados, evidenciando una carga de contaminación significativamente mayor.

```{r}
#| eval: false
#| message: false
#| warning: false
#| include: false
################################################################
############ Punto 6: Método de pseudoverosimilitud ############
################################################################

library(readxl)
library(dplyr)
library(lubridate)

pm25_data <- read_excel("PM2_5.xlsx")

datos_st <- pm25_data %>%
  rename(valor = `PM2.5`) %>%
  mutate(
    fecha = ymd(fecha),
    tiempo = as.numeric(fecha - min(fecha, na.rm = TRUE))
  ) %>%
  dplyr::select(este, norte, tiempo, valor, estacion) %>%
  na.omit()

modelo_st_separable <- function(params, h, u) {
  nugget <- params[1]; sill_esp <- params[2]; range_esp <- params[3]
  sill_temp <- params[4]; range_temp <- params[5]
  
  # Componente espacial - modelo esférico
  gamma_esp <- ifelse(h > 0, sill_esp * ((1.5 * h / range_esp) - 0.5 * (h / range_esp)^3), 0)
  gamma_esp[h > range_esp] <- sill_esp
  
  # Componente temporal - modelo esférico
  gamma_temp <- ifelse(u > 0, sill_temp * ((1.5 * u / range_temp) - 0.5 * (u / range_temp)^3), 0)
  gamma_temp[u > range_temp] <- sill_temp
  
  return(nugget + gamma_esp + gamma_temp)
}

# Función de pseudoverosimilitud
  #Negativo de la log-verosimilitud compuesta
  funcion_objetivo_cl <- function(params, datos, modelo_st_func, cutoff_esp, cutoff_temp) {
    
    n_puntos <- nrow(datos)
    nll_total <- 0
    
    if (n_puntos < 2) {
      return(0)
    }
    
    for (i in seq_len(n_puntos - 1)) {
      for (j in (i + 1):n_puntos) {
        
        # Separación espacial (h) y temporal (u)
        h <- sqrt((datos$este[i] - datos$este[j])^2 + (datos$norte[i] - datos$norte[j])^2)
        u <- abs(datos$tiempo[i] - datos$tiempo[j])
        
        if (h > cutoff_esp || u > cutoff_temp) {
          next
        }
        
        V_sq <- (datos$valor[i] - datos$valor[j])^2
        gamma_teorico <- modelo_st_func(params, h, u)
        
        if (is.na(gamma_teorico) || gamma_teorico <= 1e-9) next
        
        nll_par <- log(gamma_teorico) + V_sq / (2 * gamma_teorico)
        nll_total <- nll_total + nll_par
      }
    }
    return(nll_total)
  }


# Función de ajuste
ajustar_modelo_cl <- function(datos, valores_iniciales, cutoff_esp, cutoff_temp) {
  limites_inf <- rep(1e-6, length(valores_iniciales))
  resultado <- optim(
    par = valores_iniciales, fn = funcion_objetivo_cl, datos = datos,
    modelo_st_func = modelo_st_separable, cutoff_esp = cutoff_esp,
    cutoff_temp = cutoff_temp, method = "L-BFGS-B", lower = limites_inf,
    control = list(trace = 1, fnscale = 1e4)
  )
  return(resultado)
}

# Valores iniciales
valores_iniciales <- c(nugget=2, sill_esp=10, range_esp=15000, sill_temp=5, range_temp=60)
  
#ajuste_st <- ajustar_modelo_cl(
#    datos = datos_st,
#    valores_iniciales = valores_iniciales,
#    cutoff_esp = 25000, 
#    cutoff_temp = 180)
  
# parametros_estimados <- ajuste_st$par
# names(parametros_estimados) <- names(valores_iniciales)
# print(round(parametros_estimados, 4))

set.seed(123)
datos_prueba <- datos_st[sample(nrow(datos_st), 200), ]
ajuste_prueba <- ajustar_modelo_cl(
  datos = datos_prueba,
  valores_iniciales = valores_iniciales,
  cutoff_esp = 25000, 
  cutoff_temp = 180
)

parametros_estimados <- ajuste_prueba$par
names(parametros_estimados) <- names(valores_iniciales)
print(round(parametros_estimados, 4))
```

# REFERENCIAS

-   Secretaría Distrital de Ambiente. (2023). Informe Anual de la Red de Monitoreo de Calidad del Aire de Bogotá – RMCAB. Año 2022. Bogotá D.C.: Alcaldía Mayor de Bogotá. https://www.ambientebogota.gov.co/web/sda/informes-anuales
